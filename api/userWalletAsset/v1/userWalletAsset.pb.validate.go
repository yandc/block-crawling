// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: userWalletAsset/v1/userWalletAsset.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Currency with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Currency) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Currency with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CurrencyMultiError, or nil
// if none found.
func (m *Currency) ValidateAll() error {
	return m.validate(true)
}

func (m *Currency) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cny

	// no validation rules for Usd

	// no validation rules for Usdt

	// no validation rules for Btc

	if len(errors) > 0 {
		return CurrencyMultiError(errors)
	}

	return nil
}

// CurrencyMultiError is an error wrapping multiple validation errors returned
// by Currency.ValidateAll() if the designated constraints aren't met.
type CurrencyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CurrencyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CurrencyMultiError) AllErrors() []error { return m }

// CurrencyValidationError is the validation error returned by
// Currency.Validate if the designated constraints aren't met.
type CurrencyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CurrencyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CurrencyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CurrencyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CurrencyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CurrencyValidationError) ErrorName() string { return "CurrencyValidationError" }

// Error satisfies the builtin error interface
func (e CurrencyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCurrency.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CurrencyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CurrencyValidationError{}

// Validate checks the field values on UserWalletAssetTotalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserWalletAssetTotalReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletAssetTotalReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserWalletAssetTotalReqMultiError, or nil if none found.
func (m *UserWalletAssetTotalReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletAssetTotalReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserWalletAssetTotalReqMultiError(errors)
	}

	return nil
}

// UserWalletAssetTotalReqMultiError is an error wrapping multiple validation
// errors returned by UserWalletAssetTotalReq.ValidateAll() if the designated
// constraints aren't met.
type UserWalletAssetTotalReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletAssetTotalReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletAssetTotalReqMultiError) AllErrors() []error { return m }

// UserWalletAssetTotalReqValidationError is the validation error returned by
// UserWalletAssetTotalReq.Validate if the designated constraints aren't met.
type UserWalletAssetTotalReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletAssetTotalReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletAssetTotalReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletAssetTotalReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletAssetTotalReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletAssetTotalReqValidationError) ErrorName() string {
	return "UserWalletAssetTotalReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletAssetTotalReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletAssetTotalReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletAssetTotalReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletAssetTotalReqValidationError{}

// Validate checks the field values on UserWalletAssetTotalResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserWalletAssetTotalResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletAssetTotalResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserWalletAssetTotalRespMultiError, or nil if none found.
func (m *UserWalletAssetTotalResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletAssetTotalResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCny()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserWalletAssetTotalRespValidationError{
					field:  "Cny",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserWalletAssetTotalRespValidationError{
					field:  "Cny",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCny()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserWalletAssetTotalRespValidationError{
				field:  "Cny",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUsd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserWalletAssetTotalRespValidationError{
					field:  "Usd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserWalletAssetTotalRespValidationError{
					field:  "Usd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserWalletAssetTotalRespValidationError{
				field:  "Usd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUsdt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserWalletAssetTotalRespValidationError{
					field:  "Usdt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserWalletAssetTotalRespValidationError{
					field:  "Usdt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsdt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserWalletAssetTotalRespValidationError{
				field:  "Usdt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBtc()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserWalletAssetTotalRespValidationError{
					field:  "Btc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserWalletAssetTotalRespValidationError{
					field:  "Btc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBtc()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserWalletAssetTotalRespValidationError{
				field:  "Btc",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IncomePercentage

	if len(errors) > 0 {
		return UserWalletAssetTotalRespMultiError(errors)
	}

	return nil
}

// UserWalletAssetTotalRespMultiError is an error wrapping multiple validation
// errors returned by UserWalletAssetTotalResp.ValidateAll() if the designated
// constraints aren't met.
type UserWalletAssetTotalRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletAssetTotalRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletAssetTotalRespMultiError) AllErrors() []error { return m }

// UserWalletAssetTotalRespValidationError is the validation error returned by
// UserWalletAssetTotalResp.Validate if the designated constraints aren't met.
type UserWalletAssetTotalRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletAssetTotalRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletAssetTotalRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletAssetTotalRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletAssetTotalRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletAssetTotalRespValidationError) ErrorName() string {
	return "UserWalletAssetTotalRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletAssetTotalRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletAssetTotalResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletAssetTotalRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletAssetTotalRespValidationError{}

// Validate checks the field values on UserWalletAssetHistoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserWalletAssetHistoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletAssetHistoryReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserWalletAssetHistoryReqMultiError, or nil if none found.
func (m *UserWalletAssetHistoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletAssetHistoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Range

	// no validation rules for Platform

	if len(errors) > 0 {
		return UserWalletAssetHistoryReqMultiError(errors)
	}

	return nil
}

// UserWalletAssetHistoryReqMultiError is an error wrapping multiple validation
// errors returned by UserWalletAssetHistoryReq.ValidateAll() if the
// designated constraints aren't met.
type UserWalletAssetHistoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletAssetHistoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletAssetHistoryReqMultiError) AllErrors() []error { return m }

// UserWalletAssetHistoryReqValidationError is the validation error returned by
// UserWalletAssetHistoryReq.Validate if the designated constraints aren't met.
type UserWalletAssetHistoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletAssetHistoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletAssetHistoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletAssetHistoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletAssetHistoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletAssetHistoryReqValidationError) ErrorName() string {
	return "UserWalletAssetHistoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletAssetHistoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletAssetHistoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletAssetHistoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletAssetHistoryReqValidationError{}

// Validate checks the field values on UserWalletAssetHistoryResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserWalletAssetHistoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletAssetHistoryResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserWalletAssetHistoryRespMultiError, or nil if none found.
func (m *UserWalletAssetHistoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletAssetHistoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserWalletAssetHistoryRespValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserWalletAssetHistoryRespValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserWalletAssetHistoryRespValidationError{
				field:  "Amount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIncome()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserWalletAssetHistoryRespValidationError{
					field:  "Income",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserWalletAssetHistoryRespValidationError{
					field:  "Income",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncome()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserWalletAssetHistoryRespValidationError{
				field:  "Income",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Percentage

	for idx, item := range m.GetHistories() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserWalletAssetHistoryRespValidationError{
						field:  fmt.Sprintf("Histories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserWalletAssetHistoryRespValidationError{
						field:  fmt.Sprintf("Histories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserWalletAssetHistoryRespValidationError{
					field:  fmt.Sprintf("Histories[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserWalletAssetHistoryRespMultiError(errors)
	}

	return nil
}

// UserWalletAssetHistoryRespMultiError is an error wrapping multiple
// validation errors returned by UserWalletAssetHistoryResp.ValidateAll() if
// the designated constraints aren't met.
type UserWalletAssetHistoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletAssetHistoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletAssetHistoryRespMultiError) AllErrors() []error { return m }

// UserWalletAssetHistoryRespValidationError is the validation error returned
// by UserWalletAssetHistoryResp.Validate if the designated constraints aren't met.
type UserWalletAssetHistoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletAssetHistoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletAssetHistoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletAssetHistoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletAssetHistoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletAssetHistoryRespValidationError) ErrorName() string {
	return "UserWalletAssetHistoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletAssetHistoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletAssetHistoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletAssetHistoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletAssetHistoryRespValidationError{}

// Validate checks the field values on UserWalletIncomeHistoryReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserWalletIncomeHistoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletIncomeHistoryReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserWalletIncomeHistoryReqMultiError, or nil if none found.
func (m *UserWalletIncomeHistoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletIncomeHistoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Range

	// no validation rules for Platform

	if len(errors) > 0 {
		return UserWalletIncomeHistoryReqMultiError(errors)
	}

	return nil
}

// UserWalletIncomeHistoryReqMultiError is an error wrapping multiple
// validation errors returned by UserWalletIncomeHistoryReq.ValidateAll() if
// the designated constraints aren't met.
type UserWalletIncomeHistoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletIncomeHistoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletIncomeHistoryReqMultiError) AllErrors() []error { return m }

// UserWalletIncomeHistoryReqValidationError is the validation error returned
// by UserWalletIncomeHistoryReq.Validate if the designated constraints aren't met.
type UserWalletIncomeHistoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletIncomeHistoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletIncomeHistoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletIncomeHistoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletIncomeHistoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletIncomeHistoryReqValidationError) ErrorName() string {
	return "UserWalletIncomeHistoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletIncomeHistoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletIncomeHistoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletIncomeHistoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletIncomeHistoryReqValidationError{}

// Validate checks the field values on UserWalletIncomeHistoryResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserWalletIncomeHistoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletIncomeHistoryResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserWalletIncomeHistoryRespMultiError, or nil if none found.
func (m *UserWalletIncomeHistoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletIncomeHistoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserWalletIncomeHistoryRespValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserWalletIncomeHistoryRespValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserWalletIncomeHistoryRespValidationError{
				field:  "Amount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Percentage

	for idx, item := range m.GetHistories() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserWalletIncomeHistoryRespValidationError{
						field:  fmt.Sprintf("Histories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserWalletIncomeHistoryRespValidationError{
						field:  fmt.Sprintf("Histories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserWalletIncomeHistoryRespValidationError{
					field:  fmt.Sprintf("Histories[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserWalletIncomeHistoryRespMultiError(errors)
	}

	return nil
}

// UserWalletIncomeHistoryRespMultiError is an error wrapping multiple
// validation errors returned by UserWalletIncomeHistoryResp.ValidateAll() if
// the designated constraints aren't met.
type UserWalletIncomeHistoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletIncomeHistoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletIncomeHistoryRespMultiError) AllErrors() []error { return m }

// UserWalletIncomeHistoryRespValidationError is the validation error returned
// by UserWalletIncomeHistoryResp.Validate if the designated constraints
// aren't met.
type UserWalletIncomeHistoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletIncomeHistoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletIncomeHistoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletIncomeHistoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletIncomeHistoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletIncomeHistoryRespValidationError) ErrorName() string {
	return "UserWalletIncomeHistoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletIncomeHistoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletIncomeHistoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletIncomeHistoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletIncomeHistoryRespValidationError{}

// Validate checks the field values on UserWalletReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserWalletReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserWalletReqMultiError, or
// nil if none found.
func (m *UserWalletReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserWalletReqMultiError(errors)
	}

	return nil
}

// UserWalletReqMultiError is an error wrapping multiple validation errors
// returned by UserWalletReq.ValidateAll() if the designated constraints
// aren't met.
type UserWalletReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletReqMultiError) AllErrors() []error { return m }

// UserWalletReqValidationError is the validation error returned by
// UserWalletReq.Validate if the designated constraints aren't met.
type UserWalletReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletReqValidationError) ErrorName() string { return "UserWalletReqValidationError" }

// Error satisfies the builtin error interface
func (e UserWalletReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletReqValidationError{}

// Validate checks the field values on UserWalletResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserWalletResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserWalletRespMultiError,
// or nil if none found.
func (m *UserWalletResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserWalletList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserWalletRespValidationError{
						field:  fmt.Sprintf("UserWalletList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserWalletRespValidationError{
						field:  fmt.Sprintf("UserWalletList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserWalletRespValidationError{
					field:  fmt.Sprintf("UserWalletList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserWalletRespMultiError(errors)
	}

	return nil
}

// UserWalletRespMultiError is an error wrapping multiple validation errors
// returned by UserWalletResp.ValidateAll() if the designated constraints
// aren't met.
type UserWalletRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletRespMultiError) AllErrors() []error { return m }

// UserWalletRespValidationError is the validation error returned by
// UserWalletResp.Validate if the designated constraints aren't met.
type UserWalletRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletRespValidationError) ErrorName() string { return "UserWalletRespValidationError" }

// Error satisfies the builtin error interface
func (e UserWalletRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletRespValidationError{}

// Validate checks the field values on UserChainReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserChainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserChainReqMultiError, or
// nil if none found.
func (m *UserChainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserChainReqMultiError(errors)
	}

	return nil
}

// UserChainReqMultiError is an error wrapping multiple validation errors
// returned by UserChainReq.ValidateAll() if the designated constraints aren't met.
type UserChainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainReqMultiError) AllErrors() []error { return m }

// UserChainReqValidationError is the validation error returned by
// UserChainReq.Validate if the designated constraints aren't met.
type UserChainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainReqValidationError) ErrorName() string { return "UserChainReqValidationError" }

// Error satisfies the builtin error interface
func (e UserChainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainReqValidationError{}

// Validate checks the field values on UserChainResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserChainResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserChainRespMultiError, or
// nil if none found.
func (m *UserChainResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetChains() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserChainRespValidationError{
						field:  fmt.Sprintf("Chains[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserChainRespValidationError{
						field:  fmt.Sprintf("Chains[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserChainRespValidationError{
					field:  fmt.Sprintf("Chains[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserChainRespMultiError(errors)
	}

	return nil
}

// UserChainRespMultiError is an error wrapping multiple validation errors
// returned by UserChainResp.ValidateAll() if the designated constraints
// aren't met.
type UserChainRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainRespMultiError) AllErrors() []error { return m }

// UserChainRespValidationError is the validation error returned by
// UserChainResp.Validate if the designated constraints aren't met.
type UserChainRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainRespValidationError) ErrorName() string { return "UserChainRespValidationError" }

// Error satisfies the builtin error interface
func (e UserChainRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainRespValidationError{}

// Validate checks the field values on UserChainAmountReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChainAmountReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainAmountReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChainAmountReqMultiError, or nil if none found.
func (m *UserChainAmountReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainAmountReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserChainAmountReqMultiError(errors)
	}

	return nil
}

// UserChainAmountReqMultiError is an error wrapping multiple validation errors
// returned by UserChainAmountReq.ValidateAll() if the designated constraints
// aren't met.
type UserChainAmountReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainAmountReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainAmountReqMultiError) AllErrors() []error { return m }

// UserChainAmountReqValidationError is the validation error returned by
// UserChainAmountReq.Validate if the designated constraints aren't met.
type UserChainAmountReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainAmountReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainAmountReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainAmountReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainAmountReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainAmountReqValidationError) ErrorName() string {
	return "UserChainAmountReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainAmountReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainAmountReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainAmountReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainAmountReqValidationError{}

// Validate checks the field values on UserChainAmountResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChainAmountResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainAmountResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChainAmountRespMultiError, or nil if none found.
func (m *UserChainAmountResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainAmountResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserChainAmountList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserChainAmountRespValidationError{
						field:  fmt.Sprintf("UserChainAmountList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserChainAmountRespValidationError{
						field:  fmt.Sprintf("UserChainAmountList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserChainAmountRespValidationError{
					field:  fmt.Sprintf("UserChainAmountList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserChainAmountRespMultiError(errors)
	}

	return nil
}

// UserChainAmountRespMultiError is an error wrapping multiple validation
// errors returned by UserChainAmountResp.ValidateAll() if the designated
// constraints aren't met.
type UserChainAmountRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainAmountRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainAmountRespMultiError) AllErrors() []error { return m }

// UserChainAmountRespValidationError is the validation error returned by
// UserChainAmountResp.Validate if the designated constraints aren't met.
type UserChainAmountRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainAmountRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainAmountRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainAmountRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainAmountRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainAmountRespValidationError) ErrorName() string {
	return "UserChainAmountRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainAmountRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainAmountResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainAmountRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainAmountRespValidationError{}

// Validate checks the field values on UserTokenReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserTokenReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserTokenReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserTokenReqMultiError, or
// nil if none found.
func (m *UserTokenReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserTokenReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserTokenReqMultiError(errors)
	}

	return nil
}

// UserTokenReqMultiError is an error wrapping multiple validation errors
// returned by UserTokenReq.ValidateAll() if the designated constraints aren't met.
type UserTokenReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserTokenReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserTokenReqMultiError) AllErrors() []error { return m }

// UserTokenReqValidationError is the validation error returned by
// UserTokenReq.Validate if the designated constraints aren't met.
type UserTokenReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserTokenReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserTokenReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserTokenReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserTokenReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserTokenReqValidationError) ErrorName() string { return "UserTokenReqValidationError" }

// Error satisfies the builtin error interface
func (e UserTokenReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserTokenReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserTokenReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserTokenReqValidationError{}

// Validate checks the field values on UserTokenResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserTokenResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserTokenResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserTokenRespMultiError, or
// nil if none found.
func (m *UserTokenResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserTokenResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTokens() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserTokenRespValidationError{
						field:  fmt.Sprintf("Tokens[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserTokenRespValidationError{
						field:  fmt.Sprintf("Tokens[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserTokenRespValidationError{
					field:  fmt.Sprintf("Tokens[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserTokenRespMultiError(errors)
	}

	return nil
}

// UserTokenRespMultiError is an error wrapping multiple validation errors
// returned by UserTokenResp.ValidateAll() if the designated constraints
// aren't met.
type UserTokenRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserTokenRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserTokenRespMultiError) AllErrors() []error { return m }

// UserTokenRespValidationError is the validation error returned by
// UserTokenResp.Validate if the designated constraints aren't met.
type UserTokenRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserTokenRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserTokenRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserTokenRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserTokenRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserTokenRespValidationError) ErrorName() string { return "UserTokenRespValidationError" }

// Error satisfies the builtin error interface
func (e UserTokenRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserTokenResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserTokenRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserTokenRespValidationError{}

// Validate checks the field values on UserAssetListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserAssetListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAssetListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAssetListReqMultiError, or nil if none found.
func (m *UserAssetListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAssetListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageSize

	// no validation rules for PageNumber

	// no validation rules for Order

	// no validation rules for FillNotExitAsset

	// no validation rules for ShowTest

	// no validation rules for ShowZeroValue

	if len(errors) > 0 {
		return UserAssetListReqMultiError(errors)
	}

	return nil
}

// UserAssetListReqMultiError is an error wrapping multiple validation errors
// returned by UserAssetListReq.ValidateAll() if the designated constraints
// aren't met.
type UserAssetListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAssetListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAssetListReqMultiError) AllErrors() []error { return m }

// UserAssetListReqValidationError is the validation error returned by
// UserAssetListReq.Validate if the designated constraints aren't met.
type UserAssetListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAssetListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAssetListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAssetListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAssetListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAssetListReqValidationError) ErrorName() string { return "UserAssetListReqValidationError" }

// Error satisfies the builtin error interface
func (e UserAssetListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAssetListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAssetListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAssetListReqValidationError{}

// Validate checks the field values on UserAssetListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserAssetListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAssetListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAssetListRespMultiError, or nil if none found.
func (m *UserAssetListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAssetListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	if all {
		switch v := interface{}(m.GetTotalAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAssetListRespValidationError{
					field:  "TotalAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAssetListRespValidationError{
					field:  "TotalAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAssetListRespValidationError{
				field:  "TotalAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetUserAssetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserAssetListRespValidationError{
						field:  fmt.Sprintf("UserAssetList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserAssetListRespValidationError{
						field:  fmt.Sprintf("UserAssetList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserAssetListRespValidationError{
					field:  fmt.Sprintf("UserAssetList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserAssetListRespMultiError(errors)
	}

	return nil
}

// UserAssetListRespMultiError is an error wrapping multiple validation errors
// returned by UserAssetListResp.ValidateAll() if the designated constraints
// aren't met.
type UserAssetListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAssetListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAssetListRespMultiError) AllErrors() []error { return m }

// UserAssetListRespValidationError is the validation error returned by
// UserAssetListResp.Validate if the designated constraints aren't met.
type UserAssetListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAssetListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAssetListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAssetListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAssetListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAssetListRespValidationError) ErrorName() string {
	return "UserAssetListRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAssetListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAssetListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAssetListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAssetListRespValidationError{}

// Validate checks the field values on UserAssetDistributionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAssetDistributionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAssetDistributionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAssetDistributionReqMultiError, or nil if none found.
func (m *UserAssetDistributionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAssetDistributionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserAssetDistributionReqMultiError(errors)
	}

	return nil
}

// UserAssetDistributionReqMultiError is an error wrapping multiple validation
// errors returned by UserAssetDistributionReq.ValidateAll() if the designated
// constraints aren't met.
type UserAssetDistributionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAssetDistributionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAssetDistributionReqMultiError) AllErrors() []error { return m }

// UserAssetDistributionReqValidationError is the validation error returned by
// UserAssetDistributionReq.Validate if the designated constraints aren't met.
type UserAssetDistributionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAssetDistributionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAssetDistributionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAssetDistributionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAssetDistributionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAssetDistributionReqValidationError) ErrorName() string {
	return "UserAssetDistributionReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAssetDistributionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAssetDistributionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAssetDistributionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAssetDistributionReqValidationError{}

// Validate checks the field values on UserAssetDistributionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAssetDistributionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAssetDistributionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAssetDistributionRespMultiError, or nil if none found.
func (m *UserAssetDistributionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAssetDistributionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserAssetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserAssetDistributionRespValidationError{
						field:  fmt.Sprintf("UserAssetList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserAssetDistributionRespValidationError{
						field:  fmt.Sprintf("UserAssetList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserAssetDistributionRespValidationError{
					field:  fmt.Sprintf("UserAssetList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserAssetDistributionRespMultiError(errors)
	}

	return nil
}

// UserAssetDistributionRespMultiError is an error wrapping multiple validation
// errors returned by UserAssetDistributionResp.ValidateAll() if the
// designated constraints aren't met.
type UserAssetDistributionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAssetDistributionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAssetDistributionRespMultiError) AllErrors() []error { return m }

// UserAssetDistributionRespValidationError is the validation error returned by
// UserAssetDistributionResp.Validate if the designated constraints aren't met.
type UserAssetDistributionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAssetDistributionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAssetDistributionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAssetDistributionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAssetDistributionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAssetDistributionRespValidationError) ErrorName() string {
	return "UserAssetDistributionRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAssetDistributionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAssetDistributionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAssetDistributionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAssetDistributionRespValidationError{}

// Validate checks the field values on UserChainAssetDistributionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChainAssetDistributionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainAssetDistributionReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserChainAssetDistributionReqMultiError, or nil if none found.
func (m *UserChainAssetDistributionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainAssetDistributionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	if len(errors) > 0 {
		return UserChainAssetDistributionReqMultiError(errors)
	}

	return nil
}

// UserChainAssetDistributionReqMultiError is an error wrapping multiple
// validation errors returned by UserChainAssetDistributionReq.ValidateAll()
// if the designated constraints aren't met.
type UserChainAssetDistributionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainAssetDistributionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainAssetDistributionReqMultiError) AllErrors() []error { return m }

// UserChainAssetDistributionReqValidationError is the validation error
// returned by UserChainAssetDistributionReq.Validate if the designated
// constraints aren't met.
type UserChainAssetDistributionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainAssetDistributionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainAssetDistributionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainAssetDistributionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainAssetDistributionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainAssetDistributionReqValidationError) ErrorName() string {
	return "UserChainAssetDistributionReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainAssetDistributionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainAssetDistributionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainAssetDistributionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainAssetDistributionReqValidationError{}

// Validate checks the field values on UserChainAssetDistributionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChainAssetDistributionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainAssetDistributionResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserChainAssetDistributionRespMultiError, or nil if none found.
func (m *UserChainAssetDistributionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainAssetDistributionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserAssetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserChainAssetDistributionRespValidationError{
						field:  fmt.Sprintf("UserAssetList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserChainAssetDistributionRespValidationError{
						field:  fmt.Sprintf("UserAssetList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserChainAssetDistributionRespValidationError{
					field:  fmt.Sprintf("UserAssetList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserChainAssetDistributionRespMultiError(errors)
	}

	return nil
}

// UserChainAssetDistributionRespMultiError is an error wrapping multiple
// validation errors returned by UserChainAssetDistributionResp.ValidateAll()
// if the designated constraints aren't met.
type UserChainAssetDistributionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainAssetDistributionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainAssetDistributionRespMultiError) AllErrors() []error { return m }

// UserChainAssetDistributionRespValidationError is the validation error
// returned by UserChainAssetDistributionResp.Validate if the designated
// constraints aren't met.
type UserChainAssetDistributionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainAssetDistributionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainAssetDistributionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainAssetDistributionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainAssetDistributionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainAssetDistributionRespValidationError) ErrorName() string {
	return "UserChainAssetDistributionRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainAssetDistributionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainAssetDistributionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainAssetDistributionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainAssetDistributionRespValidationError{}

// Validate checks the field values on UserChainDistributionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChainDistributionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainDistributionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChainDistributionReqMultiError, or nil if none found.
func (m *UserChainDistributionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainDistributionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserChainDistributionReqMultiError(errors)
	}

	return nil
}

// UserChainDistributionReqMultiError is an error wrapping multiple validation
// errors returned by UserChainDistributionReq.ValidateAll() if the designated
// constraints aren't met.
type UserChainDistributionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainDistributionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainDistributionReqMultiError) AllErrors() []error { return m }

// UserChainDistributionReqValidationError is the validation error returned by
// UserChainDistributionReq.Validate if the designated constraints aren't met.
type UserChainDistributionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainDistributionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainDistributionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainDistributionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainDistributionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainDistributionReqValidationError) ErrorName() string {
	return "UserChainDistributionReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainDistributionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainDistributionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainDistributionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainDistributionReqValidationError{}

// Validate checks the field values on UserChainDistributionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChainDistributionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainDistributionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChainDistributionRespMultiError, or nil if none found.
func (m *UserChainDistributionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainDistributionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserChainList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserChainDistributionRespValidationError{
						field:  fmt.Sprintf("UserChainList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserChainDistributionRespValidationError{
						field:  fmt.Sprintf("UserChainList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserChainDistributionRespValidationError{
					field:  fmt.Sprintf("UserChainList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserChainDistributionRespMultiError(errors)
	}

	return nil
}

// UserChainDistributionRespMultiError is an error wrapping multiple validation
// errors returned by UserChainDistributionResp.ValidateAll() if the
// designated constraints aren't met.
type UserChainDistributionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainDistributionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainDistributionRespMultiError) AllErrors() []error { return m }

// UserChainDistributionRespValidationError is the validation error returned by
// UserChainDistributionResp.Validate if the designated constraints aren't met.
type UserChainDistributionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainDistributionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainDistributionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainDistributionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainDistributionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainDistributionRespValidationError) ErrorName() string {
	return "UserChainDistributionRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainDistributionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainDistributionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainDistributionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainDistributionRespValidationError{}

// Validate checks the field values on UserWalletDistributionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserWalletDistributionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletDistributionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserWalletDistributionReqMultiError, or nil if none found.
func (m *UserWalletDistributionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletDistributionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserWalletDistributionReqMultiError(errors)
	}

	return nil
}

// UserWalletDistributionReqMultiError is an error wrapping multiple validation
// errors returned by UserWalletDistributionReq.ValidateAll() if the
// designated constraints aren't met.
type UserWalletDistributionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletDistributionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletDistributionReqMultiError) AllErrors() []error { return m }

// UserWalletDistributionReqValidationError is the validation error returned by
// UserWalletDistributionReq.Validate if the designated constraints aren't met.
type UserWalletDistributionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletDistributionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletDistributionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletDistributionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletDistributionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletDistributionReqValidationError) ErrorName() string {
	return "UserWalletDistributionReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletDistributionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletDistributionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletDistributionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletDistributionReqValidationError{}

// Validate checks the field values on UserWalletDistributionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserWalletDistributionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletDistributionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserWalletDistributionRespMultiError, or nil if none found.
func (m *UserWalletDistributionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletDistributionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserWalletList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserWalletDistributionRespValidationError{
						field:  fmt.Sprintf("UserWalletList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserWalletDistributionRespValidationError{
						field:  fmt.Sprintf("UserWalletList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserWalletDistributionRespValidationError{
					field:  fmt.Sprintf("UserWalletList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserWalletDistributionRespMultiError(errors)
	}

	return nil
}

// UserWalletDistributionRespMultiError is an error wrapping multiple
// validation errors returned by UserWalletDistributionResp.ValidateAll() if
// the designated constraints aren't met.
type UserWalletDistributionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletDistributionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletDistributionRespMultiError) AllErrors() []error { return m }

// UserWalletDistributionRespValidationError is the validation error returned
// by UserWalletDistributionResp.Validate if the designated constraints aren't met.
type UserWalletDistributionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletDistributionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletDistributionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletDistributionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletDistributionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletDistributionRespValidationError) ErrorName() string {
	return "UserWalletDistributionRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletDistributionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletDistributionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletDistributionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletDistributionRespValidationError{}

// Validate checks the field values on UserChainAssetFilterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChainAssetFilterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainAssetFilterReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChainAssetFilterReqMultiError, or nil if none found.
func (m *UserChainAssetFilterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainAssetFilterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserChainAssetFilterReqMultiError(errors)
	}

	return nil
}

// UserChainAssetFilterReqMultiError is an error wrapping multiple validation
// errors returned by UserChainAssetFilterReq.ValidateAll() if the designated
// constraints aren't met.
type UserChainAssetFilterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainAssetFilterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainAssetFilterReqMultiError) AllErrors() []error { return m }

// UserChainAssetFilterReqValidationError is the validation error returned by
// UserChainAssetFilterReq.Validate if the designated constraints aren't met.
type UserChainAssetFilterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainAssetFilterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainAssetFilterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainAssetFilterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainAssetFilterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainAssetFilterReqValidationError) ErrorName() string {
	return "UserChainAssetFilterReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainAssetFilterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainAssetFilterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainAssetFilterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainAssetFilterReqValidationError{}

// Validate checks the field values on UserChainAssetFilterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChainAssetFilterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainAssetFilterResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChainAssetFilterRespMultiError, or nil if none found.
func (m *UserChainAssetFilterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainAssetFilterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserChainList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserChainAssetFilterRespValidationError{
						field:  fmt.Sprintf("UserChainList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserChainAssetFilterRespValidationError{
						field:  fmt.Sprintf("UserChainList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserChainAssetFilterRespValidationError{
					field:  fmt.Sprintf("UserChainList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserChainAssetFilterRespMultiError(errors)
	}

	return nil
}

// UserChainAssetFilterRespMultiError is an error wrapping multiple validation
// errors returned by UserChainAssetFilterResp.ValidateAll() if the designated
// constraints aren't met.
type UserChainAssetFilterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainAssetFilterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainAssetFilterRespMultiError) AllErrors() []error { return m }

// UserChainAssetFilterRespValidationError is the validation error returned by
// UserChainAssetFilterResp.Validate if the designated constraints aren't met.
type UserChainAssetFilterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainAssetFilterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainAssetFilterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainAssetFilterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainAssetFilterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainAssetFilterRespValidationError) ErrorName() string {
	return "UserChainAssetFilterRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainAssetFilterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainAssetFilterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainAssetFilterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainAssetFilterRespValidationError{}

// Validate checks the field values on
// UserWalletAssetTotalResp_UserWalletAssetTotal with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserWalletAssetTotalResp_UserWalletAssetTotal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UserWalletAssetTotalResp_UserWalletAssetTotal with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// UserWalletAssetTotalResp_UserWalletAssetTotalMultiError, or nil if none found.
func (m *UserWalletAssetTotalResp_UserWalletAssetTotal) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletAssetTotalResp_UserWalletAssetTotal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Amount

	// no validation rules for Income

	if len(errors) > 0 {
		return UserWalletAssetTotalResp_UserWalletAssetTotalMultiError(errors)
	}

	return nil
}

// UserWalletAssetTotalResp_UserWalletAssetTotalMultiError is an error wrapping
// multiple validation errors returned by
// UserWalletAssetTotalResp_UserWalletAssetTotal.ValidateAll() if the
// designated constraints aren't met.
type UserWalletAssetTotalResp_UserWalletAssetTotalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletAssetTotalResp_UserWalletAssetTotalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletAssetTotalResp_UserWalletAssetTotalMultiError) AllErrors() []error { return m }

// UserWalletAssetTotalResp_UserWalletAssetTotalValidationError is the
// validation error returned by
// UserWalletAssetTotalResp_UserWalletAssetTotal.Validate if the designated
// constraints aren't met.
type UserWalletAssetTotalResp_UserWalletAssetTotalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletAssetTotalResp_UserWalletAssetTotalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletAssetTotalResp_UserWalletAssetTotalValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e UserWalletAssetTotalResp_UserWalletAssetTotalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletAssetTotalResp_UserWalletAssetTotalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletAssetTotalResp_UserWalletAssetTotalValidationError) ErrorName() string {
	return "UserWalletAssetTotalResp_UserWalletAssetTotalValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletAssetTotalResp_UserWalletAssetTotalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletAssetTotalResp_UserWalletAssetTotal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletAssetTotalResp_UserWalletAssetTotalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletAssetTotalResp_UserWalletAssetTotalValidationError{}

// Validate checks the field values on
// UserWalletAssetHistoryResp_UserWalletAssetHistory with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserWalletAssetHistoryResp_UserWalletAssetHistory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UserWalletAssetHistoryResp_UserWalletAssetHistory with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// UserWalletAssetHistoryResp_UserWalletAssetHistoryMultiError, or nil if none found.
func (m *UserWalletAssetHistoryResp_UserWalletAssetHistory) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletAssetHistoryResp_UserWalletAssetHistory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Time

	// no validation rules for CnyAmount

	// no validation rules for UsdAmount

	// no validation rules for UsdtAmount

	// no validation rules for BtcAmount

	if len(errors) > 0 {
		return UserWalletAssetHistoryResp_UserWalletAssetHistoryMultiError(errors)
	}

	return nil
}

// UserWalletAssetHistoryResp_UserWalletAssetHistoryMultiError is an error
// wrapping multiple validation errors returned by
// UserWalletAssetHistoryResp_UserWalletAssetHistory.ValidateAll() if the
// designated constraints aren't met.
type UserWalletAssetHistoryResp_UserWalletAssetHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletAssetHistoryResp_UserWalletAssetHistoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletAssetHistoryResp_UserWalletAssetHistoryMultiError) AllErrors() []error { return m }

// UserWalletAssetHistoryResp_UserWalletAssetHistoryValidationError is the
// validation error returned by
// UserWalletAssetHistoryResp_UserWalletAssetHistory.Validate if the
// designated constraints aren't met.
type UserWalletAssetHistoryResp_UserWalletAssetHistoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletAssetHistoryResp_UserWalletAssetHistoryValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e UserWalletAssetHistoryResp_UserWalletAssetHistoryValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e UserWalletAssetHistoryResp_UserWalletAssetHistoryValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e UserWalletAssetHistoryResp_UserWalletAssetHistoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletAssetHistoryResp_UserWalletAssetHistoryValidationError) ErrorName() string {
	return "UserWalletAssetHistoryResp_UserWalletAssetHistoryValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletAssetHistoryResp_UserWalletAssetHistoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletAssetHistoryResp_UserWalletAssetHistory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletAssetHistoryResp_UserWalletAssetHistoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletAssetHistoryResp_UserWalletAssetHistoryValidationError{}

// Validate checks the field values on
// UserWalletIncomeHistoryResp_UserWalletIncomeHistory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserWalletIncomeHistoryResp_UserWalletIncomeHistory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UserWalletIncomeHistoryResp_UserWalletIncomeHistory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// UserWalletIncomeHistoryResp_UserWalletIncomeHistoryMultiError, or nil if
// none found.
func (m *UserWalletIncomeHistoryResp_UserWalletIncomeHistory) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletIncomeHistoryResp_UserWalletIncomeHistory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Time

	// no validation rules for CnyAmount

	// no validation rules for UsdAmount

	// no validation rules for UsdtAmount

	// no validation rules for BtcAmount

	if len(errors) > 0 {
		return UserWalletIncomeHistoryResp_UserWalletIncomeHistoryMultiError(errors)
	}

	return nil
}

// UserWalletIncomeHistoryResp_UserWalletIncomeHistoryMultiError is an error
// wrapping multiple validation errors returned by
// UserWalletIncomeHistoryResp_UserWalletIncomeHistory.ValidateAll() if the
// designated constraints aren't met.
type UserWalletIncomeHistoryResp_UserWalletIncomeHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletIncomeHistoryResp_UserWalletIncomeHistoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletIncomeHistoryResp_UserWalletIncomeHistoryMultiError) AllErrors() []error { return m }

// UserWalletIncomeHistoryResp_UserWalletIncomeHistoryValidationError is the
// validation error returned by
// UserWalletIncomeHistoryResp_UserWalletIncomeHistory.Validate if the
// designated constraints aren't met.
type UserWalletIncomeHistoryResp_UserWalletIncomeHistoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletIncomeHistoryResp_UserWalletIncomeHistoryValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e UserWalletIncomeHistoryResp_UserWalletIncomeHistoryValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e UserWalletIncomeHistoryResp_UserWalletIncomeHistoryValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e UserWalletIncomeHistoryResp_UserWalletIncomeHistoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletIncomeHistoryResp_UserWalletIncomeHistoryValidationError) ErrorName() string {
	return "UserWalletIncomeHistoryResp_UserWalletIncomeHistoryValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletIncomeHistoryResp_UserWalletIncomeHistoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletIncomeHistoryResp_UserWalletIncomeHistory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletIncomeHistoryResp_UserWalletIncomeHistoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletIncomeHistoryResp_UserWalletIncomeHistoryValidationError{}

// Validate checks the field values on UserWalletResp_UserWallet with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserWalletResp_UserWallet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletResp_UserWallet with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserWalletResp_UserWalletMultiError, or nil if none found.
func (m *UserWalletResp_UserWallet) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletResp_UserWallet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if all {
		switch v := interface{}(m.GetAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserWalletResp_UserWalletValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserWalletResp_UserWalletValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserWalletResp_UserWalletValidationError{
				field:  "Amount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserWalletResp_UserWalletMultiError(errors)
	}

	return nil
}

// UserWalletResp_UserWalletMultiError is an error wrapping multiple validation
// errors returned by UserWalletResp_UserWallet.ValidateAll() if the
// designated constraints aren't met.
type UserWalletResp_UserWalletMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletResp_UserWalletMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletResp_UserWalletMultiError) AllErrors() []error { return m }

// UserWalletResp_UserWalletValidationError is the validation error returned by
// UserWalletResp_UserWallet.Validate if the designated constraints aren't met.
type UserWalletResp_UserWalletValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletResp_UserWalletValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletResp_UserWalletValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletResp_UserWalletValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletResp_UserWalletValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletResp_UserWalletValidationError) ErrorName() string {
	return "UserWalletResp_UserWalletValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletResp_UserWalletValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletResp_UserWallet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletResp_UserWalletValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletResp_UserWalletValidationError{}

// Validate checks the field values on UserChainResp_UserChain with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChainResp_UserChain) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainResp_UserChain with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChainResp_UserChainMultiError, or nil if none found.
func (m *UserChainResp_UserChain) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainResp_UserChain) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for ChainLogo

	if len(errors) > 0 {
		return UserChainResp_UserChainMultiError(errors)
	}

	return nil
}

// UserChainResp_UserChainMultiError is an error wrapping multiple validation
// errors returned by UserChainResp_UserChain.ValidateAll() if the designated
// constraints aren't met.
type UserChainResp_UserChainMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainResp_UserChainMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainResp_UserChainMultiError) AllErrors() []error { return m }

// UserChainResp_UserChainValidationError is the validation error returned by
// UserChainResp_UserChain.Validate if the designated constraints aren't met.
type UserChainResp_UserChainValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainResp_UserChainValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainResp_UserChainValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainResp_UserChainValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainResp_UserChainValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainResp_UserChainValidationError) ErrorName() string {
	return "UserChainResp_UserChainValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainResp_UserChainValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainResp_UserChain.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainResp_UserChainValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainResp_UserChainValidationError{}

// Validate checks the field values on UserChainAmountResp_UserChainAmount with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UserChainAmountResp_UserChainAmount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainAmountResp_UserChainAmount
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UserChainAmountResp_UserChainAmountMultiError, or nil if none found.
func (m *UserChainAmountResp_UserChainAmount) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainAmountResp_UserChainAmount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for ChainLogo

	if all {
		switch v := interface{}(m.GetAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserChainAmountResp_UserChainAmountValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserChainAmountResp_UserChainAmountValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserChainAmountResp_UserChainAmountValidationError{
				field:  "Amount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserChainAmountResp_UserChainAmountMultiError(errors)
	}

	return nil
}

// UserChainAmountResp_UserChainAmountMultiError is an error wrapping multiple
// validation errors returned by
// UserChainAmountResp_UserChainAmount.ValidateAll() if the designated
// constraints aren't met.
type UserChainAmountResp_UserChainAmountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainAmountResp_UserChainAmountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainAmountResp_UserChainAmountMultiError) AllErrors() []error { return m }

// UserChainAmountResp_UserChainAmountValidationError is the validation error
// returned by UserChainAmountResp_UserChainAmount.Validate if the designated
// constraints aren't met.
type UserChainAmountResp_UserChainAmountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainAmountResp_UserChainAmountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainAmountResp_UserChainAmountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainAmountResp_UserChainAmountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainAmountResp_UserChainAmountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainAmountResp_UserChainAmountValidationError) ErrorName() string {
	return "UserChainAmountResp_UserChainAmountValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainAmountResp_UserChainAmountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainAmountResp_UserChainAmount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainAmountResp_UserChainAmountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainAmountResp_UserChainAmountValidationError{}

// Validate checks the field values on UserTokenResp_UserToken with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserTokenResp_UserToken) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserTokenResp_UserToken with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserTokenResp_UserTokenMultiError, or nil if none found.
func (m *UserTokenResp_UserToken) ValidateAll() error {
	return m.validate(true)
}

func (m *UserTokenResp_UserToken) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for ChainLogo

	// no validation rules for TokenAddress

	// no validation rules for TokenSymbol

	// no validation rules for TokenLogo

	if len(errors) > 0 {
		return UserTokenResp_UserTokenMultiError(errors)
	}

	return nil
}

// UserTokenResp_UserTokenMultiError is an error wrapping multiple validation
// errors returned by UserTokenResp_UserToken.ValidateAll() if the designated
// constraints aren't met.
type UserTokenResp_UserTokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserTokenResp_UserTokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserTokenResp_UserTokenMultiError) AllErrors() []error { return m }

// UserTokenResp_UserTokenValidationError is the validation error returned by
// UserTokenResp_UserToken.Validate if the designated constraints aren't met.
type UserTokenResp_UserTokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserTokenResp_UserTokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserTokenResp_UserTokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserTokenResp_UserTokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserTokenResp_UserTokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserTokenResp_UserTokenValidationError) ErrorName() string {
	return "UserTokenResp_UserTokenValidationError"
}

// Error satisfies the builtin error interface
func (e UserTokenResp_UserTokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserTokenResp_UserToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserTokenResp_UserTokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserTokenResp_UserTokenValidationError{}

// Validate checks the field values on UserAssetListResp_UserAsset with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAssetListResp_UserAsset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAssetListResp_UserAsset with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAssetListResp_UserAssetMultiError, or nil if none found.
func (m *UserAssetListResp_UserAsset) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAssetListResp_UserAsset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenAddress

	// no validation rules for TokenSymbol

	// no validation rules for TokenLogo

	// no validation rules for ChainName

	// no validation rules for Uid

	// no validation rules for Amount

	if all {
		switch v := interface{}(m.GetCurrencyAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAssetListResp_UserAssetValidationError{
					field:  "CurrencyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAssetListResp_UserAssetValidationError{
					field:  "CurrencyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrencyAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAssetListResp_UserAssetValidationError{
				field:  "CurrencyAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAssetListResp_UserAssetValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAssetListResp_UserAssetValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAssetListResp_UserAssetValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PriceDelta24H

	if all {
		switch v := interface{}(m.GetCostPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAssetListResp_UserAssetValidationError{
					field:  "CostPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAssetListResp_UserAssetValidationError{
					field:  "CostPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCostPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAssetListResp_UserAssetValidationError{
				field:  "CostPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIncome()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAssetListResp_UserAssetValidationError{
					field:  "Income",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAssetListResp_UserAssetValidationError{
					field:  "Income",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncome()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAssetListResp_UserAssetValidationError{
				field:  "Income",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IncomePercentage

	if len(errors) > 0 {
		return UserAssetListResp_UserAssetMultiError(errors)
	}

	return nil
}

// UserAssetListResp_UserAssetMultiError is an error wrapping multiple
// validation errors returned by UserAssetListResp_UserAsset.ValidateAll() if
// the designated constraints aren't met.
type UserAssetListResp_UserAssetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAssetListResp_UserAssetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAssetListResp_UserAssetMultiError) AllErrors() []error { return m }

// UserAssetListResp_UserAssetValidationError is the validation error returned
// by UserAssetListResp_UserAsset.Validate if the designated constraints
// aren't met.
type UserAssetListResp_UserAssetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAssetListResp_UserAssetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAssetListResp_UserAssetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAssetListResp_UserAssetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAssetListResp_UserAssetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAssetListResp_UserAssetValidationError) ErrorName() string {
	return "UserAssetListResp_UserAssetValidationError"
}

// Error satisfies the builtin error interface
func (e UserAssetListResp_UserAssetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAssetListResp_UserAsset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAssetListResp_UserAssetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAssetListResp_UserAssetValidationError{}

// Validate checks the field values on UserAssetDistributionResp_UserAsset with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UserAssetDistributionResp_UserAsset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAssetDistributionResp_UserAsset
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UserAssetDistributionResp_UserAssetMultiError, or nil if none found.
func (m *UserAssetDistributionResp_UserAsset) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAssetDistributionResp_UserAsset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenSymbol

	// no validation rules for Amount

	if all {
		switch v := interface{}(m.GetCurrencyAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAssetDistributionResp_UserAssetValidationError{
					field:  "CurrencyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAssetDistributionResp_UserAssetValidationError{
					field:  "CurrencyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrencyAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAssetDistributionResp_UserAssetValidationError{
				field:  "CurrencyAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Percentage

	if len(errors) > 0 {
		return UserAssetDistributionResp_UserAssetMultiError(errors)
	}

	return nil
}

// UserAssetDistributionResp_UserAssetMultiError is an error wrapping multiple
// validation errors returned by
// UserAssetDistributionResp_UserAsset.ValidateAll() if the designated
// constraints aren't met.
type UserAssetDistributionResp_UserAssetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAssetDistributionResp_UserAssetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAssetDistributionResp_UserAssetMultiError) AllErrors() []error { return m }

// UserAssetDistributionResp_UserAssetValidationError is the validation error
// returned by UserAssetDistributionResp_UserAsset.Validate if the designated
// constraints aren't met.
type UserAssetDistributionResp_UserAssetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAssetDistributionResp_UserAssetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAssetDistributionResp_UserAssetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAssetDistributionResp_UserAssetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAssetDistributionResp_UserAssetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAssetDistributionResp_UserAssetValidationError) ErrorName() string {
	return "UserAssetDistributionResp_UserAssetValidationError"
}

// Error satisfies the builtin error interface
func (e UserAssetDistributionResp_UserAssetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAssetDistributionResp_UserAsset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAssetDistributionResp_UserAssetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAssetDistributionResp_UserAssetValidationError{}

// Validate checks the field values on UserChainAssetDistributionResp_UserAsset
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UserChainAssetDistributionResp_UserAsset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UserChainAssetDistributionResp_UserAsset with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// UserChainAssetDistributionResp_UserAssetMultiError, or nil if none found.
func (m *UserChainAssetDistributionResp_UserAsset) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainAssetDistributionResp_UserAsset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenSymbol

	// no validation rules for Amount

	if all {
		switch v := interface{}(m.GetCurrencyAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserChainAssetDistributionResp_UserAssetValidationError{
					field:  "CurrencyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserChainAssetDistributionResp_UserAssetValidationError{
					field:  "CurrencyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrencyAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserChainAssetDistributionResp_UserAssetValidationError{
				field:  "CurrencyAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Percentage

	if len(errors) > 0 {
		return UserChainAssetDistributionResp_UserAssetMultiError(errors)
	}

	return nil
}

// UserChainAssetDistributionResp_UserAssetMultiError is an error wrapping
// multiple validation errors returned by
// UserChainAssetDistributionResp_UserAsset.ValidateAll() if the designated
// constraints aren't met.
type UserChainAssetDistributionResp_UserAssetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainAssetDistributionResp_UserAssetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainAssetDistributionResp_UserAssetMultiError) AllErrors() []error { return m }

// UserChainAssetDistributionResp_UserAssetValidationError is the validation
// error returned by UserChainAssetDistributionResp_UserAsset.Validate if the
// designated constraints aren't met.
type UserChainAssetDistributionResp_UserAssetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainAssetDistributionResp_UserAssetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainAssetDistributionResp_UserAssetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainAssetDistributionResp_UserAssetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainAssetDistributionResp_UserAssetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainAssetDistributionResp_UserAssetValidationError) ErrorName() string {
	return "UserChainAssetDistributionResp_UserAssetValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainAssetDistributionResp_UserAssetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainAssetDistributionResp_UserAsset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainAssetDistributionResp_UserAssetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainAssetDistributionResp_UserAssetValidationError{}

// Validate checks the field values on UserChainDistributionResp_UserChain with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UserChainDistributionResp_UserChain) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainDistributionResp_UserChain
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UserChainDistributionResp_UserChainMultiError, or nil if none found.
func (m *UserChainDistributionResp_UserChain) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainDistributionResp_UserChain) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	if all {
		switch v := interface{}(m.GetCurrencyAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserChainDistributionResp_UserChainValidationError{
					field:  "CurrencyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserChainDistributionResp_UserChainValidationError{
					field:  "CurrencyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrencyAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserChainDistributionResp_UserChainValidationError{
				field:  "CurrencyAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Percentage

	if len(errors) > 0 {
		return UserChainDistributionResp_UserChainMultiError(errors)
	}

	return nil
}

// UserChainDistributionResp_UserChainMultiError is an error wrapping multiple
// validation errors returned by
// UserChainDistributionResp_UserChain.ValidateAll() if the designated
// constraints aren't met.
type UserChainDistributionResp_UserChainMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainDistributionResp_UserChainMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainDistributionResp_UserChainMultiError) AllErrors() []error { return m }

// UserChainDistributionResp_UserChainValidationError is the validation error
// returned by UserChainDistributionResp_UserChain.Validate if the designated
// constraints aren't met.
type UserChainDistributionResp_UserChainValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainDistributionResp_UserChainValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainDistributionResp_UserChainValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainDistributionResp_UserChainValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainDistributionResp_UserChainValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainDistributionResp_UserChainValidationError) ErrorName() string {
	return "UserChainDistributionResp_UserChainValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainDistributionResp_UserChainValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainDistributionResp_UserChain.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainDistributionResp_UserChainValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainDistributionResp_UserChainValidationError{}

// Validate checks the field values on UserWalletDistributionResp_UserWallet
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UserWalletDistributionResp_UserWallet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserWalletDistributionResp_UserWallet
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UserWalletDistributionResp_UserWalletMultiError, or nil if none found.
func (m *UserWalletDistributionResp_UserWallet) ValidateAll() error {
	return m.validate(true)
}

func (m *UserWalletDistributionResp_UserWallet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if all {
		switch v := interface{}(m.GetCurrencyAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserWalletDistributionResp_UserWalletValidationError{
					field:  "CurrencyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserWalletDistributionResp_UserWalletValidationError{
					field:  "CurrencyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrencyAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserWalletDistributionResp_UserWalletValidationError{
				field:  "CurrencyAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Percentage

	if len(errors) > 0 {
		return UserWalletDistributionResp_UserWalletMultiError(errors)
	}

	return nil
}

// UserWalletDistributionResp_UserWalletMultiError is an error wrapping
// multiple validation errors returned by
// UserWalletDistributionResp_UserWallet.ValidateAll() if the designated
// constraints aren't met.
type UserWalletDistributionResp_UserWalletMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserWalletDistributionResp_UserWalletMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserWalletDistributionResp_UserWalletMultiError) AllErrors() []error { return m }

// UserWalletDistributionResp_UserWalletValidationError is the validation error
// returned by UserWalletDistributionResp_UserWallet.Validate if the
// designated constraints aren't met.
type UserWalletDistributionResp_UserWalletValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserWalletDistributionResp_UserWalletValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserWalletDistributionResp_UserWalletValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserWalletDistributionResp_UserWalletValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserWalletDistributionResp_UserWalletValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserWalletDistributionResp_UserWalletValidationError) ErrorName() string {
	return "UserWalletDistributionResp_UserWalletValidationError"
}

// Error satisfies the builtin error interface
func (e UserWalletDistributionResp_UserWalletValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserWalletDistributionResp_UserWallet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserWalletDistributionResp_UserWalletValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserWalletDistributionResp_UserWalletValidationError{}

// Validate checks the field values on UserChainAssetFilterResp_UserChain with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UserChainAssetFilterResp_UserChain) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainAssetFilterResp_UserChain
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UserChainAssetFilterResp_UserChainMultiError, or nil if none found.
func (m *UserChainAssetFilterResp_UserChain) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainAssetFilterResp_UserChain) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	for idx, item := range m.GetUserChainAssetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserChainAssetFilterResp_UserChainValidationError{
						field:  fmt.Sprintf("UserChainAssetList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserChainAssetFilterResp_UserChainValidationError{
						field:  fmt.Sprintf("UserChainAssetList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserChainAssetFilterResp_UserChainValidationError{
					field:  fmt.Sprintf("UserChainAssetList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserChainAssetFilterResp_UserChainMultiError(errors)
	}

	return nil
}

// UserChainAssetFilterResp_UserChainMultiError is an error wrapping multiple
// validation errors returned by
// UserChainAssetFilterResp_UserChain.ValidateAll() if the designated
// constraints aren't met.
type UserChainAssetFilterResp_UserChainMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainAssetFilterResp_UserChainMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainAssetFilterResp_UserChainMultiError) AllErrors() []error { return m }

// UserChainAssetFilterResp_UserChainValidationError is the validation error
// returned by UserChainAssetFilterResp_UserChain.Validate if the designated
// constraints aren't met.
type UserChainAssetFilterResp_UserChainValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainAssetFilterResp_UserChainValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainAssetFilterResp_UserChainValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainAssetFilterResp_UserChainValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainAssetFilterResp_UserChainValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainAssetFilterResp_UserChainValidationError) ErrorName() string {
	return "UserChainAssetFilterResp_UserChainValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainAssetFilterResp_UserChainValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainAssetFilterResp_UserChain.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainAssetFilterResp_UserChainValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainAssetFilterResp_UserChainValidationError{}

// Validate checks the field values on UserChainAssetFilterResp_UserChainAsset
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UserChainAssetFilterResp_UserChainAsset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UserChainAssetFilterResp_UserChainAsset with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// UserChainAssetFilterResp_UserChainAssetMultiError, or nil if none found.
func (m *UserChainAssetFilterResp_UserChainAsset) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainAssetFilterResp_UserChainAsset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Address

	if len(errors) > 0 {
		return UserChainAssetFilterResp_UserChainAssetMultiError(errors)
	}

	return nil
}

// UserChainAssetFilterResp_UserChainAssetMultiError is an error wrapping
// multiple validation errors returned by
// UserChainAssetFilterResp_UserChainAsset.ValidateAll() if the designated
// constraints aren't met.
type UserChainAssetFilterResp_UserChainAssetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainAssetFilterResp_UserChainAssetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainAssetFilterResp_UserChainAssetMultiError) AllErrors() []error { return m }

// UserChainAssetFilterResp_UserChainAssetValidationError is the validation
// error returned by UserChainAssetFilterResp_UserChainAsset.Validate if the
// designated constraints aren't met.
type UserChainAssetFilterResp_UserChainAssetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainAssetFilterResp_UserChainAssetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainAssetFilterResp_UserChainAssetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainAssetFilterResp_UserChainAssetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainAssetFilterResp_UserChainAssetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainAssetFilterResp_UserChainAssetValidationError) ErrorName() string {
	return "UserChainAssetFilterResp_UserChainAssetValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainAssetFilterResp_UserChainAssetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainAssetFilterResp_UserChainAsset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainAssetFilterResp_UserChainAssetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainAssetFilterResp_UserChainAssetValidationError{}
