// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/transaction/v1/transaction.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on JsonReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JsonReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JsonReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JsonReqMultiError, or nil if none found.
func (m *JsonReq) ValidateAll() error {
	return m.validate(true)
}

func (m *JsonReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetMethod()) < 1 {
		err := JsonReqValidationError{
			field:  "Method",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUid()) < 1 {
		err := JsonReqValidationError{
			field:  "Uid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ChainName

	// no validation rules for Params

	// no validation rules for Device

	if len(errors) > 0 {
		return JsonReqMultiError(errors)
	}

	return nil
}

// JsonReqMultiError is an error wrapping multiple validation errors returned
// by JsonReq.ValidateAll() if the designated constraints aren't met.
type JsonReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JsonReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JsonReqMultiError) AllErrors() []error { return m }

// JsonReqValidationError is the validation error returned by JsonReq.Validate
// if the designated constraints aren't met.
type JsonReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JsonReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JsonReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JsonReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JsonReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JsonReqValidationError) ErrorName() string { return "JsonReqValidationError" }

// Error satisfies the builtin error interface
func (e JsonReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJsonReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JsonReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JsonReqValidationError{}

// Validate checks the field values on JsonResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JsonResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JsonResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JsonResponseMultiError, or
// nil if none found.
func (m *JsonResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *JsonResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	// no validation rules for Response

	// no validation rules for ErrorMsg

	if len(errors) > 0 {
		return JsonResponseMultiError(errors)
	}

	return nil
}

// JsonResponseMultiError is an error wrapping multiple validation errors
// returned by JsonResponse.ValidateAll() if the designated constraints aren't met.
type JsonResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JsonResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JsonResponseMultiError) AllErrors() []error { return m }

// JsonResponseValidationError is the validation error returned by
// JsonResponse.Validate if the designated constraints aren't met.
type JsonResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JsonResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JsonResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JsonResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JsonResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JsonResponseValidationError) ErrorName() string { return "JsonResponseValidationError" }

// Error satisfies the builtin error interface
func (e JsonResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJsonResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JsonResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JsonResponseValidationError{}

// Validate checks the field values on NftRecordReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NftRecordReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NftRecordReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NftRecordReqMultiError, or
// nil if none found.
func (m *NftRecordReq) ValidateAll() error {
	return m.validate(true)
}

func (m *NftRecordReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for ContractAddress

	// no validation rules for TokenId

	if len(errors) > 0 {
		return NftRecordReqMultiError(errors)
	}

	return nil
}

// NftRecordReqMultiError is an error wrapping multiple validation errors
// returned by NftRecordReq.ValidateAll() if the designated constraints aren't met.
type NftRecordReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NftRecordReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NftRecordReqMultiError) AllErrors() []error { return m }

// NftRecordReqValidationError is the validation error returned by
// NftRecordReq.Validate if the designated constraints aren't met.
type NftRecordReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NftRecordReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NftRecordReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NftRecordReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NftRecordReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NftRecordReqValidationError) ErrorName() string { return "NftRecordReqValidationError" }

// Error satisfies the builtin error interface
func (e NftRecordReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNftRecordReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NftRecordReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NftRecordReqValidationError{}

// Validate checks the field values on NftRecordResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NftRecordResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NftRecordResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NftRecordResponseMultiError, or nil if none found.
func (m *NftRecordResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *NftRecordResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NftRecordResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NftRecordResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NftRecordResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NftRecordResponseMultiError(errors)
	}

	return nil
}

// NftRecordResponseMultiError is an error wrapping multiple validation errors
// returned by NftRecordResponse.ValidateAll() if the designated constraints
// aren't met.
type NftRecordResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NftRecordResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NftRecordResponseMultiError) AllErrors() []error { return m }

// NftRecordResponseValidationError is the validation error returned by
// NftRecordResponse.Validate if the designated constraints aren't met.
type NftRecordResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NftRecordResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NftRecordResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NftRecordResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NftRecordResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NftRecordResponseValidationError) ErrorName() string {
	return "NftRecordResponseValidationError"
}

// Error satisfies the builtin error interface
func (e NftRecordResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNftRecordResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NftRecordResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NftRecordResponseValidationError{}

// Validate checks the field values on NftHistoryList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NftHistoryList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NftHistoryList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NftHistoryListMultiError,
// or nil if none found.
func (m *NftHistoryList) ValidateAll() error {
	return m.validate(true)
}

func (m *NftHistoryList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FromAddress

	// no validation rules for ToAddress

	// no validation rules for Quantity

	// no validation rules for TxTime

	// no validation rules for TransactionType

	// no validation rules for TransactionHash

	if len(errors) > 0 {
		return NftHistoryListMultiError(errors)
	}

	return nil
}

// NftHistoryListMultiError is an error wrapping multiple validation errors
// returned by NftHistoryList.ValidateAll() if the designated constraints
// aren't met.
type NftHistoryListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NftHistoryListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NftHistoryListMultiError) AllErrors() []error { return m }

// NftHistoryListValidationError is the validation error returned by
// NftHistoryList.Validate if the designated constraints aren't met.
type NftHistoryListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NftHistoryListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NftHistoryListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NftHistoryListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NftHistoryListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NftHistoryListValidationError) ErrorName() string { return "NftHistoryListValidationError" }

// Error satisfies the builtin error interface
func (e NftHistoryListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNftHistoryList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NftHistoryListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NftHistoryListValidationError{}

// Validate checks the field values on UnspentReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UnspentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnspentReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UnspentReqMultiError, or
// nil if none found.
func (m *UnspentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UnspentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for IsUnspent

	// no validation rules for Uid

	// no validation rules for Address

	// no validation rules for TxHash

	// no validation rules for ContractAddress

	if len(errors) > 0 {
		return UnspentReqMultiError(errors)
	}

	return nil
}

// UnspentReqMultiError is an error wrapping multiple validation errors
// returned by UnspentReq.ValidateAll() if the designated constraints aren't met.
type UnspentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnspentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnspentReqMultiError) AllErrors() []error { return m }

// UnspentReqValidationError is the validation error returned by
// UnspentReq.Validate if the designated constraints aren't met.
type UnspentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnspentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnspentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnspentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnspentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnspentReqValidationError) ErrorName() string { return "UnspentReqValidationError" }

// Error satisfies the builtin error interface
func (e UnspentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnspentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnspentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnspentReqValidationError{}

// Validate checks the field values on UnspentResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UnspentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnspentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnspentResponseMultiError, or nil if none found.
func (m *UnspentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnspentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	for idx, item := range m.GetCellList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UnspentResponseValidationError{
						field:  fmt.Sprintf("CellList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UnspentResponseValidationError{
						field:  fmt.Sprintf("CellList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UnspentResponseValidationError{
					field:  fmt.Sprintf("CellList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetUtxoList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UnspentResponseValidationError{
						field:  fmt.Sprintf("UtxoList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UnspentResponseValidationError{
						field:  fmt.Sprintf("UtxoList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UnspentResponseValidationError{
					field:  fmt.Sprintf("UtxoList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTokenCellList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UnspentResponseValidationError{
						field:  fmt.Sprintf("TokenCellList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UnspentResponseValidationError{
						field:  fmt.Sprintf("TokenCellList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UnspentResponseValidationError{
					field:  fmt.Sprintf("TokenCellList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UnspentResponseMultiError(errors)
	}

	return nil
}

// UnspentResponseMultiError is an error wrapping multiple validation errors
// returned by UnspentResponse.ValidateAll() if the designated constraints
// aren't met.
type UnspentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnspentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnspentResponseMultiError) AllErrors() []error { return m }

// UnspentResponseValidationError is the validation error returned by
// UnspentResponse.Validate if the designated constraints aren't met.
type UnspentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnspentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnspentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnspentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnspentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnspentResponseValidationError) ErrorName() string { return "UnspentResponseValidationError" }

// Error satisfies the builtin error interface
func (e UnspentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnspentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnspentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnspentResponseValidationError{}

// Validate checks the field values on UnspentList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UnspentList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnspentList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UnspentListMultiError, or
// nil if none found.
func (m *UnspentList) ValidateAll() error {
	return m.validate(true)
}

func (m *UnspentList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	// no validation rules for Hash

	// no validation rules for Index

	// no validation rules for ChainName

	// no validation rules for Address

	// no validation rules for Script

	// no validation rules for Unspent

	// no validation rules for Amount

	// no validation rules for TxTime

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return UnspentListMultiError(errors)
	}

	return nil
}

// UnspentListMultiError is an error wrapping multiple validation errors
// returned by UnspentList.ValidateAll() if the designated constraints aren't met.
type UnspentListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnspentListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnspentListMultiError) AllErrors() []error { return m }

// UnspentListValidationError is the validation error returned by
// UnspentList.Validate if the designated constraints aren't met.
type UnspentListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnspentListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnspentListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnspentListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnspentListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnspentListValidationError) ErrorName() string { return "UnspentListValidationError" }

// Error satisfies the builtin error interface
func (e UnspentListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnspentList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnspentListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnspentListValidationError{}

// Validate checks the field values on CellList with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CellList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CellList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CellListMultiError, or nil
// if none found.
func (m *CellList) ValidateAll() error {
	return m.validate(true)
}

func (m *CellList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CellListValidationError{
					field:  "OutPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CellListValidationError{
					field:  "OutPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CellListValidationError{
				field:  "OutPoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Capacity

	if all {
		switch v := interface{}(m.GetLock()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CellListValidationError{
					field:  "Lock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CellListValidationError{
					field:  "Lock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLock()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CellListValidationError{
				field:  "Lock",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CellListValidationError{
					field:  "Type",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CellListValidationError{
					field:  "Type",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CellListValidationError{
				field:  "Type",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Data

	if len(errors) > 0 {
		return CellListMultiError(errors)
	}

	return nil
}

// CellListMultiError is an error wrapping multiple validation errors returned
// by CellList.ValidateAll() if the designated constraints aren't met.
type CellListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CellListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CellListMultiError) AllErrors() []error { return m }

// CellListValidationError is the validation error returned by
// CellList.Validate if the designated constraints aren't met.
type CellListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CellListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CellListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CellListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CellListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CellListValidationError) ErrorName() string { return "CellListValidationError" }

// Error satisfies the builtin error interface
func (e CellListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCellList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CellListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CellListValidationError{}

// Validate checks the field values on OutPoint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OutPoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OutPoint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OutPointMultiError, or nil
// if none found.
func (m *OutPoint) ValidateAll() error {
	return m.validate(true)
}

func (m *OutPoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxHash

	// no validation rules for Index

	if len(errors) > 0 {
		return OutPointMultiError(errors)
	}

	return nil
}

// OutPointMultiError is an error wrapping multiple validation errors returned
// by OutPoint.ValidateAll() if the designated constraints aren't met.
type OutPointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OutPointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OutPointMultiError) AllErrors() []error { return m }

// OutPointValidationError is the validation error returned by
// OutPoint.Validate if the designated constraints aren't met.
type OutPointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OutPointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OutPointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OutPointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OutPointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OutPointValidationError) ErrorName() string { return "OutPointValidationError" }

// Error satisfies the builtin error interface
func (e OutPointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOutPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OutPointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OutPointValidationError{}

// Validate checks the field values on CellLock with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CellLock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CellLock with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CellLockMultiError, or nil
// if none found.
func (m *CellLock) ValidateAll() error {
	return m.validate(true)
}

func (m *CellLock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CodeHash

	// no validation rules for HashType

	// no validation rules for Args

	if len(errors) > 0 {
		return CellLockMultiError(errors)
	}

	return nil
}

// CellLockMultiError is an error wrapping multiple validation errors returned
// by CellLock.ValidateAll() if the designated constraints aren't met.
type CellLockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CellLockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CellLockMultiError) AllErrors() []error { return m }

// CellLockValidationError is the validation error returned by
// CellLock.Validate if the designated constraints aren't met.
type CellLockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CellLockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CellLockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CellLockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CellLockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CellLockValidationError) ErrorName() string { return "CellLockValidationError" }

// Error satisfies the builtin error interface
func (e CellLockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCellLock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CellLockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CellLockValidationError{}

// Validate checks the field values on DappPageListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DappPageListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappPageListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DappPageListReqMultiError, or nil if none found.
func (m *DappPageListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DappPageListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for ContractAddress

	// no validation rules for Page

	// no validation rules for Limit

	// no validation rules for Fromuid

	// no validation rules for FromAddress

	// no validation rules for OrderBy

	if _, ok := _DappPageListReq_DataDirection_InLookup[m.GetDataDirection()]; !ok {
		err := DappPageListReqValidationError{
			field:  "DataDirection",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStartIndex() < 0 {
		err := DappPageListReqValidationError{
			field:  "StartIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DappType

	// no validation rules for Platform

	// no validation rules for OsVersion

	if len(errors) > 0 {
		return DappPageListReqMultiError(errors)
	}

	return nil
}

// DappPageListReqMultiError is an error wrapping multiple validation errors
// returned by DappPageListReq.ValidateAll() if the designated constraints
// aren't met.
type DappPageListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappPageListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappPageListReqMultiError) AllErrors() []error { return m }

// DappPageListReqValidationError is the validation error returned by
// DappPageListReq.Validate if the designated constraints aren't met.
type DappPageListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappPageListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappPageListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappPageListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappPageListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappPageListReqValidationError) ErrorName() string { return "DappPageListReqValidationError" }

// Error satisfies the builtin error interface
func (e DappPageListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappPageListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappPageListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappPageListReqValidationError{}

var _DappPageListReq_DataDirection_InLookup = map[int32]struct{}{
	0: {},
	1: {},
	2: {},
}

// Validate checks the field values on DappPageListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DappPageListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappPageListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DappPageListRespMultiError, or nil if none found.
func (m *DappPageListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DappPageListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DappPageListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DappPageListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DappPageListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DappPageListRespMultiError(errors)
	}

	return nil
}

// DappPageListRespMultiError is an error wrapping multiple validation errors
// returned by DappPageListResp.ValidateAll() if the designated constraints
// aren't met.
type DappPageListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappPageListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappPageListRespMultiError) AllErrors() []error { return m }

// DappPageListRespValidationError is the validation error returned by
// DappPageListResp.Validate if the designated constraints aren't met.
type DappPageListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappPageListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappPageListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappPageListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappPageListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappPageListRespValidationError) ErrorName() string { return "DappPageListRespValidationError" }

// Error satisfies the builtin error interface
func (e DappPageListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappPageListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappPageListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappPageListRespValidationError{}

// Validate checks the field values on DappPageData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DappPageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappPageData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DappPageDataMultiError, or
// nil if none found.
func (m *DappPageData) ValidateAll() error {
	return m.validate(true)
}

func (m *DappPageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Limit

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DappPageDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DappPageDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DappPageDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DappPageDataMultiError(errors)
	}

	return nil
}

// DappPageDataMultiError is an error wrapping multiple validation errors
// returned by DappPageData.ValidateAll() if the designated constraints aren't met.
type DappPageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappPageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappPageDataMultiError) AllErrors() []error { return m }

// DappPageDataValidationError is the validation error returned by
// DappPageData.Validate if the designated constraints aren't met.
type DappPageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappPageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappPageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappPageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappPageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappPageDataValidationError) ErrorName() string { return "DappPageDataValidationError" }

// Error satisfies the builtin error interface
func (e DappPageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappPageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappPageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappPageDataValidationError{}

// Validate checks the field values on NonceReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NonceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NonceReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NonceReqMultiError, or nil
// if none found.
func (m *NonceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *NonceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChainName()) < 1 {
		err := NonceReqValidationError{
			field:  "ChainName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAddress()) < 1 {
		err := NonceReqValidationError{
			field:  "Address",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return NonceReqMultiError(errors)
	}

	return nil
}

// NonceReqMultiError is an error wrapping multiple validation errors returned
// by NonceReq.ValidateAll() if the designated constraints aren't met.
type NonceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NonceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NonceReqMultiError) AllErrors() []error { return m }

// NonceReqValidationError is the validation error returned by
// NonceReq.Validate if the designated constraints aren't met.
type NonceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NonceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NonceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NonceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NonceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NonceReqValidationError) ErrorName() string { return "NonceReqValidationError" }

// Error satisfies the builtin error interface
func (e NonceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNonceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NonceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NonceReqValidationError{}

// Validate checks the field values on NonceResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NonceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NonceResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NonceRespMultiError, or nil
// if none found.
func (m *NonceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *NonceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	// no validation rules for Nonce

	if len(errors) > 0 {
		return NonceRespMultiError(errors)
	}

	return nil
}

// NonceRespMultiError is an error wrapping multiple validation errors returned
// by NonceResp.ValidateAll() if the designated constraints aren't met.
type NonceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NonceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NonceRespMultiError) AllErrors() []error { return m }

// NonceRespValidationError is the validation error returned by
// NonceResp.Validate if the designated constraints aren't met.
type NonceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NonceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NonceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NonceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NonceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NonceRespValidationError) ErrorName() string { return "NonceRespValidationError" }

// Error satisfies the builtin error interface
func (e NonceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNonceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NonceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NonceRespValidationError{}

// Validate checks the field values on OpenAmountReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenAmountReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAmountReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpenAmountReqMultiError, or
// nil if none found.
func (m *OpenAmountReq) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAmountReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Currency

	// no validation rules for ChainName

	// no validation rules for Address

	// no validation rules for ContractAddress

	if len(errors) > 0 {
		return OpenAmountReqMultiError(errors)
	}

	return nil
}

// OpenAmountReqMultiError is an error wrapping multiple validation errors
// returned by OpenAmountReq.ValidateAll() if the designated constraints
// aren't met.
type OpenAmountReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAmountReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAmountReqMultiError) AllErrors() []error { return m }

// OpenAmountReqValidationError is the validation error returned by
// OpenAmountReq.Validate if the designated constraints aren't met.
type OpenAmountReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAmountReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAmountReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAmountReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAmountReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAmountReqValidationError) ErrorName() string { return "OpenAmountReqValidationError" }

// Error satisfies the builtin error interface
func (e OpenAmountReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAmountReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAmountReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAmountReqValidationError{}

// Validate checks the field values on OpenAmoutResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenAmoutResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAmoutResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpenAmoutRespMultiError, or
// nil if none found.
func (m *OpenAmoutResp) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAmoutResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OpenAmoutRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OpenAmoutRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OpenAmoutRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OpenAmoutRespMultiError(errors)
	}

	return nil
}

// OpenAmoutRespMultiError is an error wrapping multiple validation errors
// returned by OpenAmoutResp.ValidateAll() if the designated constraints
// aren't met.
type OpenAmoutRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAmoutRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAmoutRespMultiError) AllErrors() []error { return m }

// OpenAmoutRespValidationError is the validation error returned by
// OpenAmoutResp.Validate if the designated constraints aren't met.
type OpenAmoutRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAmoutRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAmoutRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAmoutRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAmoutRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAmoutRespValidationError) ErrorName() string { return "OpenAmoutRespValidationError" }

// Error satisfies the builtin error interface
func (e OpenAmoutRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAmoutResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAmoutRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAmoutRespValidationError{}

// Validate checks the field values on OpenAmountInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenAmountInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAmountInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpenAmountInfoMultiError,
// or nil if none found.
func (m *OpenAmountInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAmountInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RiskExposureAmount

	// no validation rules for DappCount

	if len(errors) > 0 {
		return OpenAmountInfoMultiError(errors)
	}

	return nil
}

// OpenAmountInfoMultiError is an error wrapping multiple validation errors
// returned by OpenAmountInfo.ValidateAll() if the designated constraints
// aren't met.
type OpenAmountInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAmountInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAmountInfoMultiError) AllErrors() []error { return m }

// OpenAmountInfoValidationError is the validation error returned by
// OpenAmountInfo.Validate if the designated constraints aren't met.
type OpenAmountInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAmountInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAmountInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAmountInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAmountInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAmountInfoValidationError) ErrorName() string { return "OpenAmountInfoValidationError" }

// Error satisfies the builtin error interface
func (e OpenAmountInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAmountInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAmountInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAmountInfoValidationError{}

// Validate checks the field values on DappListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DappListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DappListReqMultiError, or
// nil if none found.
func (m *DappListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DappListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for ChainName

	// no validation rules for ContractAddress

	// no validation rules for IsCancel

	// no validation rules for IsCancelStatus

	// no validation rules for DappType

	// no validation rules for Platform

	// no validation rules for OsVersion

	if len(errors) > 0 {
		return DappListReqMultiError(errors)
	}

	return nil
}

// DappListReqMultiError is an error wrapping multiple validation errors
// returned by DappListReq.ValidateAll() if the designated constraints aren't met.
type DappListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappListReqMultiError) AllErrors() []error { return m }

// DappListReqValidationError is the validation error returned by
// DappListReq.Validate if the designated constraints aren't met.
type DappListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappListReqValidationError) ErrorName() string { return "DappListReqValidationError" }

// Error satisfies the builtin error interface
func (e DappListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappListReqValidationError{}

// Validate checks the field values on DappListResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DappListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DappListRespMultiError, or
// nil if none found.
func (m *DappListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DappListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DappListRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DappListRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DappListRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DappListRespMultiError(errors)
	}

	return nil
}

// DappListRespMultiError is an error wrapping multiple validation errors
// returned by DappListResp.ValidateAll() if the designated constraints aren't met.
type DappListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappListRespMultiError) AllErrors() []error { return m }

// DappListRespValidationError is the validation error returned by
// DappListResp.Validate if the designated constraints aren't met.
type DappListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappListRespValidationError) ErrorName() string { return "DappListRespValidationError" }

// Error satisfies the builtin error interface
func (e DappListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappListRespValidationError{}

// Validate checks the field values on DappInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DappInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DappInfoMultiError, or nil
// if none found.
func (m *DappInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DappInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContractAddress

	// no validation rules for Chain

	// no validation rules for Uid

	// no validation rules for LastTxhash

	// no validation rules for Decimals

	// no validation rules for Address

	// no validation rules for Token

	// no validation rules for ToAddress

	// no validation rules for Amount

	// no validation rules for Original

	// no validation rules for Symbol

	// no validation rules for DappInfo

	// no validation rules for Status

	// no validation rules for TxTime

	// no validation rules for DappType

	// no validation rules for CollectionName

	// no validation rules for Logo

	if len(errors) > 0 {
		return DappInfoMultiError(errors)
	}

	return nil
}

// DappInfoMultiError is an error wrapping multiple validation errors returned
// by DappInfo.ValidateAll() if the designated constraints aren't met.
type DappInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappInfoMultiError) AllErrors() []error { return m }

// DappInfoValidationError is the validation error returned by
// DappInfo.Validate if the designated constraints aren't met.
type DappInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappInfoValidationError) ErrorName() string { return "DappInfoValidationError" }

// Error satisfies the builtin error interface
func (e DappInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappInfoValidationError{}

// Validate checks the field values on CreateResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateResponseMultiError,
// or nil if none found.
func (m *CreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Code

	// no validation rules for Mes

	if len(errors) > 0 {
		return CreateResponseMultiError(errors)
	}

	return nil
}

// CreateResponseMultiError is an error wrapping multiple validation errors
// returned by CreateResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateResponseMultiError) AllErrors() []error { return m }

// CreateResponseValidationError is the validation error returned by
// CreateResponse.Validate if the designated constraints aren't met.
type CreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateResponseValidationError) ErrorName() string { return "CreateResponseValidationError" }

// Error satisfies the builtin error interface
func (e CreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateResponseValidationError{}

// Validate checks the field values on TransactionReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransactionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransactionReqMultiError,
// or nil if none found.
func (m *TransactionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if utf8.RuneCountInString(m.GetChainName()) < 1 {
		err := TransactionReqValidationError{
			field:  "ChainName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTransactionHash()) < 1 {
		err := TransactionReqValidationError{
			field:  "TransactionHash",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetStatus()) < 1 {
		err := TransactionReqValidationError{
			field:  "Status",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFromAddress()) < 1 {
		err := TransactionReqValidationError{
			field:  "FromAddress",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ToAddress

	// no validation rules for Amount

	// no validation rules for FeeAmount

	// no validation rules for TransactionType

	// no validation rules for ContractAddress

	// no validation rules for TxTime

	// no validation rules for Nonce

	// no validation rules for GasLimit

	// no validation rules for GasUsed

	// no validation rules for GasPrice

	// no validation rules for BaseFee

	// no validation rules for Data

	// no validation rules for DappData

	// no validation rules for EventLog

	// no validation rules for ParseData

	// no validation rules for NetUsage

	// no validation rules for FeeLimit

	// no validation rules for EnergyUsage

	// no validation rules for BlockHash

	// no validation rules for BlockNumber

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for ClientData

	// no validation rules for MaxFeePerGas

	// no validation rules for MaxPriorityFeePerGas

	// no validation rules for FeeData

	// no validation rules for OperateType

	// no validation rules for OriginalHash

	if len(errors) > 0 {
		return TransactionReqMultiError(errors)
	}

	return nil
}

// TransactionReqMultiError is an error wrapping multiple validation errors
// returned by TransactionReq.ValidateAll() if the designated constraints
// aren't met.
type TransactionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionReqMultiError) AllErrors() []error { return m }

// TransactionReqValidationError is the validation error returned by
// TransactionReq.Validate if the designated constraints aren't met.
type TransactionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionReqValidationError) ErrorName() string { return "TransactionReqValidationError" }

// Error satisfies the builtin error interface
func (e TransactionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionReqValidationError{}

// Validate checks the field values on PageListRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PageListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListRequestMultiError, or nil if none found.
func (m *PageListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChainName()) < 1 {
		err := PageListRequestValidationError{
			field:  "ChainName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FromUid

	// no validation rules for ToUid

	// no validation rules for Uid

	// no validation rules for Address

	// no validation rules for ContractAddress

	if m.GetStartTime() < 0 {
		err := PageListRequestValidationError{
			field:  "StartTime",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStopTime() < 0 {
		err := PageListRequestValidationError{
			field:  "StopTime",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OrderBy

	if _, ok := _PageListRequest_DataDirection_InLookup[m.GetDataDirection()]; !ok {
		err := PageListRequestValidationError{
			field:  "DataDirection",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStartIndex() < 0 {
		err := PageListRequestValidationError{
			field:  "StartIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := PageListRequestValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() < 0 {
		err := PageListRequestValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Total

	// no validation rules for Platform

	// no validation rules for OsVersion

	// no validation rules for TokenAddress

	// no validation rules for AssetType

	if len(errors) > 0 {
		return PageListRequestMultiError(errors)
	}

	return nil
}

// PageListRequestMultiError is an error wrapping multiple validation errors
// returned by PageListRequest.ValidateAll() if the designated constraints
// aren't met.
type PageListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListRequestMultiError) AllErrors() []error { return m }

// PageListRequestValidationError is the validation error returned by
// PageListRequest.Validate if the designated constraints aren't met.
type PageListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListRequestValidationError) ErrorName() string { return "PageListRequestValidationError" }

// Error satisfies the builtin error interface
func (e PageListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListRequestValidationError{}

var _PageListRequest_DataDirection_InLookup = map[int32]struct{}{
	0: {},
	1: {},
	2: {},
}

// Validate checks the field values on PageListResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PageListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListResponseMultiError, or nil if none found.
func (m *PageListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PageListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PageListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PageListResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PageListResponseMultiError(errors)
	}

	return nil
}

// PageListResponseMultiError is an error wrapping multiple validation errors
// returned by PageListResponse.ValidateAll() if the designated constraints
// aren't met.
type PageListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListResponseMultiError) AllErrors() []error { return m }

// PageListResponseValidationError is the validation error returned by
// PageListResponse.Validate if the designated constraints aren't met.
type PageListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListResponseValidationError) ErrorName() string { return "PageListResponseValidationError" }

// Error satisfies the builtin error interface
func (e PageListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListResponseValidationError{}

// Validate checks the field values on TransactionRecord with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransactionRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionRecordMultiError, or nil if none found.
func (m *TransactionRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ChainName

	// no validation rules for BlockHash

	// no validation rules for BlockNumber

	// no validation rules for TransactionHash

	// no validation rules for FromAddress

	// no validation rules for ToAddress

	// no validation rules for FromUid

	// no validation rules for ToUid

	// no validation rules for Amount

	// no validation rules for FeeAmount

	// no validation rules for Status

	// no validation rules for TransactionType

	// no validation rules for ContractAddress

	// no validation rules for TxTime

	// no validation rules for Nonce

	// no validation rules for GasLimit

	// no validation rules for GasUsed

	// no validation rules for GasPrice

	// no validation rules for BaseFee

	// no validation rules for MaxFeePerGas

	// no validation rules for MaxPriorityFeePerGas

	// no validation rules for Data

	// no validation rules for DappData

	// no validation rules for EventLog

	// no validation rules for ParseData

	// no validation rules for NetUsage

	// no validation rules for FeeLimit

	// no validation rules for EnergyUsage

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for ClientData

	// no validation rules for FeeData

	// no validation rules for Cursor

	// no validation rules for OperateType

	// no validation rules for OriginalHash

	for idx, item := range m.GetOperateRecordList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionRecordValidationError{
						field:  fmt.Sprintf("OperateRecordList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionRecordValidationError{
						field:  fmt.Sprintf("OperateRecordList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionRecordValidationError{
					field:  fmt.Sprintf("OperateRecordList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TransactionRecordMultiError(errors)
	}

	return nil
}

// TransactionRecordMultiError is an error wrapping multiple validation errors
// returned by TransactionRecord.ValidateAll() if the designated constraints
// aren't met.
type TransactionRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionRecordMultiError) AllErrors() []error { return m }

// TransactionRecordValidationError is the validation error returned by
// TransactionRecord.Validate if the designated constraints aren't met.
type TransactionRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionRecordValidationError) ErrorName() string {
	return "TransactionRecordValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionRecordValidationError{}

// Validate checks the field values on AmountRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AmountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmountRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AmountRequestMultiError, or
// nil if none found.
func (m *AmountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AmountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChainName()) < 1 {
		err := AmountRequestValidationError{
			field:  "ChainName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FromUid

	// no validation rules for ToUid

	if len(errors) > 0 {
		return AmountRequestMultiError(errors)
	}

	return nil
}

// AmountRequestMultiError is an error wrapping multiple validation errors
// returned by AmountRequest.ValidateAll() if the designated constraints
// aren't met.
type AmountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmountRequestMultiError) AllErrors() []error { return m }

// AmountRequestValidationError is the validation error returned by
// AmountRequest.Validate if the designated constraints aren't met.
type AmountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmountRequestValidationError) ErrorName() string { return "AmountRequestValidationError" }

// Error satisfies the builtin error interface
func (e AmountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmountRequestValidationError{}

// Validate checks the field values on AmountResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AmountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmountResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AmountResponseMultiError,
// or nil if none found.
func (m *AmountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AmountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Amount

	if len(errors) > 0 {
		return AmountResponseMultiError(errors)
	}

	return nil
}

// AmountResponseMultiError is an error wrapping multiple validation errors
// returned by AmountResponse.ValidateAll() if the designated constraints
// aren't met.
type AmountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmountResponseMultiError) AllErrors() []error { return m }

// AmountResponseValidationError is the validation error returned by
// AmountResponse.Validate if the designated constraints aren't met.
type AmountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmountResponseValidationError) ErrorName() string { return "AmountResponseValidationError" }

// Error satisfies the builtin error interface
func (e AmountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmountResponseValidationError{}

// Validate checks the field values on PageListAssetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PageListAssetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListAssetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListAssetRequestMultiError, or nil if none found.
func (m *PageListAssetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListAssetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for Uid

	// no validation rules for Currency

	if _, ok := _PageListAssetRequest_AmountType_InLookup[m.GetAmountType()]; !ok {
		err := PageListAssetRequestValidationError{
			field:  "AmountType",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OrderBy

	if _, ok := _PageListAssetRequest_DataDirection_InLookup[m.GetDataDirection()]; !ok {
		err := PageListAssetRequestValidationError{
			field:  "DataDirection",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStartIndex() < 0 {
		err := PageListAssetRequestValidationError{
			field:  "StartIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := PageListAssetRequestValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() < 0 {
		err := PageListAssetRequestValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Total

	if len(errors) > 0 {
		return PageListAssetRequestMultiError(errors)
	}

	return nil
}

// PageListAssetRequestMultiError is an error wrapping multiple validation
// errors returned by PageListAssetRequest.ValidateAll() if the designated
// constraints aren't met.
type PageListAssetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListAssetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListAssetRequestMultiError) AllErrors() []error { return m }

// PageListAssetRequestValidationError is the validation error returned by
// PageListAssetRequest.Validate if the designated constraints aren't met.
type PageListAssetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListAssetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListAssetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListAssetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListAssetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListAssetRequestValidationError) ErrorName() string {
	return "PageListAssetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PageListAssetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListAssetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListAssetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListAssetRequestValidationError{}

var _PageListAssetRequest_AmountType_InLookup = map[int32]struct{}{
	0: {},
	1: {},
	2: {},
}

var _PageListAssetRequest_DataDirection_InLookup = map[int32]struct{}{
	0: {},
	1: {},
	2: {},
}

// Validate checks the field values on PageListAssetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PageListAssetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListAssetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListAssetResponseMultiError, or nil if none found.
func (m *PageListAssetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListAssetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	// no validation rules for TotalCurrencyAmount

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PageListAssetResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PageListAssetResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PageListAssetResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PageListAssetResponseMultiError(errors)
	}

	return nil
}

// PageListAssetResponseMultiError is an error wrapping multiple validation
// errors returned by PageListAssetResponse.ValidateAll() if the designated
// constraints aren't met.
type PageListAssetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListAssetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListAssetResponseMultiError) AllErrors() []error { return m }

// PageListAssetResponseValidationError is the validation error returned by
// PageListAssetResponse.Validate if the designated constraints aren't met.
type PageListAssetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListAssetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListAssetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListAssetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListAssetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListAssetResponseValidationError) ErrorName() string {
	return "PageListAssetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PageListAssetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListAssetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListAssetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListAssetResponseValidationError{}

// Validate checks the field values on AssetResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetResponseMultiError, or
// nil if none found.
func (m *AssetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ChainName

	// no validation rules for Uid

	// no validation rules for Address

	// no validation rules for TokenAddress

	// no validation rules for Balance

	// no validation rules for Decimals

	// no validation rules for Symbol

	// no validation rules for CurrencyAmount

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for Cursor

	// no validation rules for Price

	if len(errors) > 0 {
		return AssetResponseMultiError(errors)
	}

	return nil
}

// AssetResponseMultiError is an error wrapping multiple validation errors
// returned by AssetResponse.ValidateAll() if the designated constraints
// aren't met.
type AssetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetResponseMultiError) AllErrors() []error { return m }

// AssetResponseValidationError is the validation error returned by
// AssetResponse.Validate if the designated constraints aren't met.
type AssetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetResponseValidationError) ErrorName() string { return "AssetResponseValidationError" }

// Error satisfies the builtin error interface
func (e AssetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetResponseValidationError{}

// Validate checks the field values on AssetRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetRequestMultiError, or
// nil if none found.
func (m *AssetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChainName()) < 1 {
		err := AssetRequestValidationError{
			field:  "ChainName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAddress()) < 1 {
		err := AssetRequestValidationError{
			field:  "Address",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTokenAddressList()) < 1 {
		err := AssetRequestValidationError{
			field:  "TokenAddressList",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AssetRequestMultiError(errors)
	}

	return nil
}

// AssetRequestMultiError is an error wrapping multiple validation errors
// returned by AssetRequest.ValidateAll() if the designated constraints aren't met.
type AssetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetRequestMultiError) AllErrors() []error { return m }

// AssetRequestValidationError is the validation error returned by
// AssetRequest.Validate if the designated constraints aren't met.
type AssetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetRequestValidationError) ErrorName() string { return "AssetRequestValidationError" }

// Error satisfies the builtin error interface
func (e AssetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetRequestValidationError{}

// Validate checks the field values on ListBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBalanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBalanceResponseMultiError, or nil if none found.
func (m *ListBalanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBalanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListBalanceResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListBalanceResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListBalanceResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListBalanceResponseMultiError(errors)
	}

	return nil
}

// ListBalanceResponseMultiError is an error wrapping multiple validation
// errors returned by ListBalanceResponse.ValidateAll() if the designated
// constraints aren't met.
type ListBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBalanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBalanceResponseMultiError) AllErrors() []error { return m }

// ListBalanceResponseValidationError is the validation error returned by
// ListBalanceResponse.Validate if the designated constraints aren't met.
type ListBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBalanceResponseValidationError) ErrorName() string {
	return "ListBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBalanceResponseValidationError{}

// Validate checks the field values on BalanceResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BalanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BalanceResponseMultiError, or nil if none found.
func (m *BalanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BalanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenAddress

	// no validation rules for Balance

	if len(errors) > 0 {
		return BalanceResponseMultiError(errors)
	}

	return nil
}

// BalanceResponseMultiError is an error wrapping multiple validation errors
// returned by BalanceResponse.ValidateAll() if the designated constraints
// aren't met.
type BalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceResponseMultiError) AllErrors() []error { return m }

// BalanceResponseValidationError is the validation error returned by
// BalanceResponse.Validate if the designated constraints aren't met.
type BalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceResponseValidationError) ErrorName() string { return "BalanceResponseValidationError" }

// Error satisfies the builtin error interface
func (e BalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceResponseValidationError{}

// Validate checks the field values on ListAmountUidDimensionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAmountUidDimensionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAmountUidDimensionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListAmountUidDimensionRequestMultiError, or nil if none found.
func (m *ListAmountUidDimensionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAmountUidDimensionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	if len(m.GetUidList()) < 1 {
		err := ListAmountUidDimensionRequestValidationError{
			field:  "UidList",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListAmountUidDimensionRequestMultiError(errors)
	}

	return nil
}

// ListAmountUidDimensionRequestMultiError is an error wrapping multiple
// validation errors returned by ListAmountUidDimensionRequest.ValidateAll()
// if the designated constraints aren't met.
type ListAmountUidDimensionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAmountUidDimensionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAmountUidDimensionRequestMultiError) AllErrors() []error { return m }

// ListAmountUidDimensionRequestValidationError is the validation error
// returned by ListAmountUidDimensionRequest.Validate if the designated
// constraints aren't met.
type ListAmountUidDimensionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAmountUidDimensionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAmountUidDimensionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAmountUidDimensionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAmountUidDimensionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAmountUidDimensionRequestValidationError) ErrorName() string {
	return "ListAmountUidDimensionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAmountUidDimensionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAmountUidDimensionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAmountUidDimensionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAmountUidDimensionRequestValidationError{}

// Validate checks the field values on ListAmountUidDimensionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAmountUidDimensionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAmountUidDimensionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListAmountUidDimensionResponseMultiError, or nil if none found.
func (m *ListAmountUidDimensionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAmountUidDimensionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAmountUidDimensionResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAmountUidDimensionResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAmountUidDimensionResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListAmountUidDimensionResponseMultiError(errors)
	}

	return nil
}

// ListAmountUidDimensionResponseMultiError is an error wrapping multiple
// validation errors returned by ListAmountUidDimensionResponse.ValidateAll()
// if the designated constraints aren't met.
type ListAmountUidDimensionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAmountUidDimensionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAmountUidDimensionResponseMultiError) AllErrors() []error { return m }

// ListAmountUidDimensionResponseValidationError is the validation error
// returned by ListAmountUidDimensionResponse.Validate if the designated
// constraints aren't met.
type ListAmountUidDimensionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAmountUidDimensionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAmountUidDimensionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAmountUidDimensionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAmountUidDimensionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAmountUidDimensionResponseValidationError) ErrorName() string {
	return "ListAmountUidDimensionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAmountUidDimensionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAmountUidDimensionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAmountUidDimensionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAmountUidDimensionResponseValidationError{}

// Validate checks the field values on AmountUidDimensionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AmountUidDimensionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmountUidDimensionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AmountUidDimensionResponseMultiError, or nil if none found.
func (m *AmountUidDimensionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AmountUidDimensionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for CurrencyAmount

	if len(errors) > 0 {
		return AmountUidDimensionResponseMultiError(errors)
	}

	return nil
}

// AmountUidDimensionResponseMultiError is an error wrapping multiple
// validation errors returned by AmountUidDimensionResponse.ValidateAll() if
// the designated constraints aren't met.
type AmountUidDimensionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmountUidDimensionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmountUidDimensionResponseMultiError) AllErrors() []error { return m }

// AmountUidDimensionResponseValidationError is the validation error returned
// by AmountUidDimensionResponse.Validate if the designated constraints aren't met.
type AmountUidDimensionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmountUidDimensionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmountUidDimensionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmountUidDimensionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmountUidDimensionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmountUidDimensionResponseValidationError) ErrorName() string {
	return "AmountUidDimensionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AmountUidDimensionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmountUidDimensionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmountUidDimensionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmountUidDimensionResponseValidationError{}

// Validate checks the field values on ListHasBalanceUidDimensionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListHasBalanceUidDimensionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListHasBalanceUidDimensionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListHasBalanceUidDimensionRequestMultiError, or nil if none found.
func (m *ListHasBalanceUidDimensionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListHasBalanceUidDimensionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetUidList()) < 1 {
		err := ListHasBalanceUidDimensionRequestValidationError{
			field:  "UidList",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListHasBalanceUidDimensionRequestMultiError(errors)
	}

	return nil
}

// ListHasBalanceUidDimensionRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListHasBalanceUidDimensionRequest.ValidateAll() if the designated
// constraints aren't met.
type ListHasBalanceUidDimensionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHasBalanceUidDimensionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHasBalanceUidDimensionRequestMultiError) AllErrors() []error { return m }

// ListHasBalanceUidDimensionRequestValidationError is the validation error
// returned by ListHasBalanceUidDimensionRequest.Validate if the designated
// constraints aren't met.
type ListHasBalanceUidDimensionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHasBalanceUidDimensionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHasBalanceUidDimensionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHasBalanceUidDimensionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHasBalanceUidDimensionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHasBalanceUidDimensionRequestValidationError) ErrorName() string {
	return "ListHasBalanceUidDimensionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListHasBalanceUidDimensionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHasBalanceUidDimensionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHasBalanceUidDimensionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHasBalanceUidDimensionRequestValidationError{}

// Validate checks the field values on ListHasBalanceUidDimensionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListHasBalanceUidDimensionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListHasBalanceUidDimensionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListHasBalanceUidDimensionResponseMultiError, or nil if none found.
func (m *ListHasBalanceUidDimensionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListHasBalanceUidDimensionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListHasBalanceUidDimensionResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListHasBalanceUidDimensionResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListHasBalanceUidDimensionResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListHasBalanceUidDimensionResponseMultiError(errors)
	}

	return nil
}

// ListHasBalanceUidDimensionResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListHasBalanceUidDimensionResponse.ValidateAll() if the designated
// constraints aren't met.
type ListHasBalanceUidDimensionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHasBalanceUidDimensionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHasBalanceUidDimensionResponseMultiError) AllErrors() []error { return m }

// ListHasBalanceUidDimensionResponseValidationError is the validation error
// returned by ListHasBalanceUidDimensionResponse.Validate if the designated
// constraints aren't met.
type ListHasBalanceUidDimensionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHasBalanceUidDimensionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHasBalanceUidDimensionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHasBalanceUidDimensionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHasBalanceUidDimensionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHasBalanceUidDimensionResponseValidationError) ErrorName() string {
	return "ListHasBalanceUidDimensionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListHasBalanceUidDimensionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHasBalanceUidDimensionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHasBalanceUidDimensionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHasBalanceUidDimensionResponseValidationError{}

// Validate checks the field values on HasBalanceUidDimensionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HasBalanceUidDimensionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HasBalanceUidDimensionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// HasBalanceUidDimensionResponseMultiError, or nil if none found.
func (m *HasBalanceUidDimensionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HasBalanceUidDimensionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for HasBalance

	if len(errors) > 0 {
		return HasBalanceUidDimensionResponseMultiError(errors)
	}

	return nil
}

// HasBalanceUidDimensionResponseMultiError is an error wrapping multiple
// validation errors returned by HasBalanceUidDimensionResponse.ValidateAll()
// if the designated constraints aren't met.
type HasBalanceUidDimensionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HasBalanceUidDimensionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HasBalanceUidDimensionResponseMultiError) AllErrors() []error { return m }

// HasBalanceUidDimensionResponseValidationError is the validation error
// returned by HasBalanceUidDimensionResponse.Validate if the designated
// constraints aren't met.
type HasBalanceUidDimensionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HasBalanceUidDimensionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HasBalanceUidDimensionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HasBalanceUidDimensionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HasBalanceUidDimensionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HasBalanceUidDimensionResponseValidationError) ErrorName() string {
	return "HasBalanceUidDimensionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HasBalanceUidDimensionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHasBalanceUidDimensionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HasBalanceUidDimensionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HasBalanceUidDimensionResponseValidationError{}

// Validate checks the field values on PageListNftAssetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PageListNftAssetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListNftAssetRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListNftAssetRequestMultiError, or nil if none found.
func (m *PageListNftAssetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListNftAssetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for Uid

	// no validation rules for Currency

	if _, ok := _PageListNftAssetRequest_AmountType_InLookup[m.GetAmountType()]; !ok {
		err := PageListNftAssetRequestValidationError{
			field:  "AmountType",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CollectionNameLike

	// no validation rules for OrderBy

	if _, ok := _PageListNftAssetRequest_DataDirection_InLookup[m.GetDataDirection()]; !ok {
		err := PageListNftAssetRequestValidationError{
			field:  "DataDirection",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStartIndex() < 0 {
		err := PageListNftAssetRequestValidationError{
			field:  "StartIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := PageListNftAssetRequestValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() < 0 {
		err := PageListNftAssetRequestValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Total

	// no validation rules for CollectionNameLikeIgnoreCase

	if len(errors) > 0 {
		return PageListNftAssetRequestMultiError(errors)
	}

	return nil
}

// PageListNftAssetRequestMultiError is an error wrapping multiple validation
// errors returned by PageListNftAssetRequest.ValidateAll() if the designated
// constraints aren't met.
type PageListNftAssetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListNftAssetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListNftAssetRequestMultiError) AllErrors() []error { return m }

// PageListNftAssetRequestValidationError is the validation error returned by
// PageListNftAssetRequest.Validate if the designated constraints aren't met.
type PageListNftAssetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListNftAssetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListNftAssetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListNftAssetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListNftAssetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListNftAssetRequestValidationError) ErrorName() string {
	return "PageListNftAssetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PageListNftAssetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListNftAssetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListNftAssetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListNftAssetRequestValidationError{}

var _PageListNftAssetRequest_AmountType_InLookup = map[int32]struct{}{
	0: {},
	1: {},
	2: {},
}

var _PageListNftAssetRequest_DataDirection_InLookup = map[int32]struct{}{
	0: {},
	1: {},
	2: {},
}

// Validate checks the field values on ClientPageListNftAssetGroupResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ClientPageListNftAssetGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientPageListNftAssetGroupResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ClientPageListNftAssetGroupResponseMultiError, or nil if none found.
func (m *ClientPageListNftAssetGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientPageListNftAssetGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClientPageListNftAssetGroupResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClientPageListNftAssetGroupResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClientPageListNftAssetGroupResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalBalance

	if len(errors) > 0 {
		return ClientPageListNftAssetGroupResponseMultiError(errors)
	}

	return nil
}

// ClientPageListNftAssetGroupResponseMultiError is an error wrapping multiple
// validation errors returned by
// ClientPageListNftAssetGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type ClientPageListNftAssetGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientPageListNftAssetGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientPageListNftAssetGroupResponseMultiError) AllErrors() []error { return m }

// ClientPageListNftAssetGroupResponseValidationError is the validation error
// returned by ClientPageListNftAssetGroupResponse.Validate if the designated
// constraints aren't met.
type ClientPageListNftAssetGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientPageListNftAssetGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientPageListNftAssetGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientPageListNftAssetGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientPageListNftAssetGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientPageListNftAssetGroupResponseValidationError) ErrorName() string {
	return "ClientPageListNftAssetGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ClientPageListNftAssetGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientPageListNftAssetGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientPageListNftAssetGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientPageListNftAssetGroupResponseValidationError{}

// Validate checks the field values on ClientNftAssetGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClientNftAssetGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientNftAssetGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClientNftAssetGroupResponseMultiError, or nil if none found.
func (m *ClientNftAssetGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientNftAssetGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for Uid

	// no validation rules for Address

	// no validation rules for TokenAddress

	// no validation rules for TokenUri

	// no validation rules for Balance

	// no validation rules for TokenType

	// no validation rules for CollectionName

	// no validation rules for TokenIdAmount

	// no validation rules for Cursor

	if len(errors) > 0 {
		return ClientNftAssetGroupResponseMultiError(errors)
	}

	return nil
}

// ClientNftAssetGroupResponseMultiError is an error wrapping multiple
// validation errors returned by ClientNftAssetGroupResponse.ValidateAll() if
// the designated constraints aren't met.
type ClientNftAssetGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientNftAssetGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientNftAssetGroupResponseMultiError) AllErrors() []error { return m }

// ClientNftAssetGroupResponseValidationError is the validation error returned
// by ClientNftAssetGroupResponse.Validate if the designated constraints
// aren't met.
type ClientNftAssetGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientNftAssetGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientNftAssetGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientNftAssetGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientNftAssetGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientNftAssetGroupResponseValidationError) ErrorName() string {
	return "ClientNftAssetGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ClientNftAssetGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientNftAssetGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientNftAssetGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientNftAssetGroupResponseValidationError{}

// Validate checks the field values on ClientPageListNftAssetResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClientPageListNftAssetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientPageListNftAssetResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ClientPageListNftAssetResponseMultiError, or nil if none found.
func (m *ClientPageListNftAssetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientPageListNftAssetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClientPageListNftAssetResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClientPageListNftAssetResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClientPageListNftAssetResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClientPageListNftAssetResponseMultiError(errors)
	}

	return nil
}

// ClientPageListNftAssetResponseMultiError is an error wrapping multiple
// validation errors returned by ClientPageListNftAssetResponse.ValidateAll()
// if the designated constraints aren't met.
type ClientPageListNftAssetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientPageListNftAssetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientPageListNftAssetResponseMultiError) AllErrors() []error { return m }

// ClientPageListNftAssetResponseValidationError is the validation error
// returned by ClientPageListNftAssetResponse.Validate if the designated
// constraints aren't met.
type ClientPageListNftAssetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientPageListNftAssetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientPageListNftAssetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientPageListNftAssetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientPageListNftAssetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientPageListNftAssetResponseValidationError) ErrorName() string {
	return "ClientPageListNftAssetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ClientPageListNftAssetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientPageListNftAssetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientPageListNftAssetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientPageListNftAssetResponseValidationError{}

// Validate checks the field values on ClientNftAssetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClientNftAssetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientNftAssetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClientNftAssetResponseMultiError, or nil if none found.
func (m *ClientNftAssetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientNftAssetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ChainName

	// no validation rules for Uid

	// no validation rules for Address

	// no validation rules for TokenAddress

	// no validation rules for TokenUri

	// no validation rules for TokenId

	// no validation rules for Balance

	// no validation rules for TokenType

	// no validation rules for CollectionName

	// no validation rules for Symbol

	// no validation rules for Name

	// no validation rules for ItemName

	// no validation rules for ItemUri

	// no validation rules for ItemOriginalUri

	// no validation rules for ItemAnimationUri

	// no validation rules for Data

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for Cursor

	if len(errors) > 0 {
		return ClientNftAssetResponseMultiError(errors)
	}

	return nil
}

// ClientNftAssetResponseMultiError is an error wrapping multiple validation
// errors returned by ClientNftAssetResponse.ValidateAll() if the designated
// constraints aren't met.
type ClientNftAssetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientNftAssetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientNftAssetResponseMultiError) AllErrors() []error { return m }

// ClientNftAssetResponseValidationError is the validation error returned by
// ClientNftAssetResponse.Validate if the designated constraints aren't met.
type ClientNftAssetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientNftAssetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientNftAssetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientNftAssetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientNftAssetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientNftAssetResponseValidationError) ErrorName() string {
	return "ClientNftAssetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ClientNftAssetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientNftAssetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientNftAssetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientNftAssetResponseValidationError{}

// Validate checks the field values on NftAssetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NftAssetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NftAssetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NftAssetRequestMultiError, or nil if none found.
func (m *NftAssetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *NftAssetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChainName()) < 1 {
		err := NftAssetRequestValidationError{
			field:  "ChainName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAddress()) < 1 {
		err := NftAssetRequestValidationError{
			field:  "Address",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTokenAddress()) < 1 {
		err := NftAssetRequestValidationError{
			field:  "TokenAddress",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTokenId()) < 1 {
		err := NftAssetRequestValidationError{
			field:  "TokenId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return NftAssetRequestMultiError(errors)
	}

	return nil
}

// NftAssetRequestMultiError is an error wrapping multiple validation errors
// returned by NftAssetRequest.ValidateAll() if the designated constraints
// aren't met.
type NftAssetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NftAssetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NftAssetRequestMultiError) AllErrors() []error { return m }

// NftAssetRequestValidationError is the validation error returned by
// NftAssetRequest.Validate if the designated constraints aren't met.
type NftAssetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NftAssetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NftAssetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NftAssetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NftAssetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NftAssetRequestValidationError) ErrorName() string { return "NftAssetRequestValidationError" }

// Error satisfies the builtin error interface
func (e NftAssetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNftAssetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NftAssetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NftAssetRequestValidationError{}

// Validate checks the field values on NftBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NftBalanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NftBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NftBalanceResponseMultiError, or nil if none found.
func (m *NftBalanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *NftBalanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Balance

	if len(errors) > 0 {
		return NftBalanceResponseMultiError(errors)
	}

	return nil
}

// NftBalanceResponseMultiError is an error wrapping multiple validation errors
// returned by NftBalanceResponse.ValidateAll() if the designated constraints
// aren't met.
type NftBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NftBalanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NftBalanceResponseMultiError) AllErrors() []error { return m }

// NftBalanceResponseValidationError is the validation error returned by
// NftBalanceResponse.Validate if the designated constraints aren't met.
type NftBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NftBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NftBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NftBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NftBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NftBalanceResponseValidationError) ErrorName() string {
	return "NftBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e NftBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNftBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NftBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NftBalanceResponseValidationError{}

// Validate checks the field values on PageListStatisticRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PageListStatisticRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListStatisticRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListStatisticRequestMultiError, or nil if none found.
func (m *PageListStatisticRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListStatisticRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for TokenAddress

	if m.GetStartTime() < 0 {
		err := PageListStatisticRequestValidationError{
			field:  "StartTime",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStopTime() < 0 {
		err := PageListStatisticRequestValidationError{
			field:  "StopTime",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OrderBy

	if _, ok := _PageListStatisticRequest_DataDirection_InLookup[m.GetDataDirection()]; !ok {
		err := PageListStatisticRequestValidationError{
			field:  "DataDirection",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStartIndex() < 0 {
		err := PageListStatisticRequestValidationError{
			field:  "StartIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := PageListStatisticRequestValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() < 0 {
		err := PageListStatisticRequestValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Total

	if len(errors) > 0 {
		return PageListStatisticRequestMultiError(errors)
	}

	return nil
}

// PageListStatisticRequestMultiError is an error wrapping multiple validation
// errors returned by PageListStatisticRequest.ValidateAll() if the designated
// constraints aren't met.
type PageListStatisticRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListStatisticRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListStatisticRequestMultiError) AllErrors() []error { return m }

// PageListStatisticRequestValidationError is the validation error returned by
// PageListStatisticRequest.Validate if the designated constraints aren't met.
type PageListStatisticRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListStatisticRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListStatisticRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListStatisticRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListStatisticRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListStatisticRequestValidationError) ErrorName() string {
	return "PageListStatisticRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PageListStatisticRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListStatisticRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListStatisticRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListStatisticRequestValidationError{}

var _PageListStatisticRequest_DataDirection_InLookup = map[int32]struct{}{
	0: {},
	1: {},
	2: {},
}

// Validate checks the field values on PageListStatisticResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PageListStatisticResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListStatisticResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListStatisticResponseMultiError, or nil if none found.
func (m *PageListStatisticResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListStatisticResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PageListStatisticResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PageListStatisticResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PageListStatisticResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PageListStatisticResponseMultiError(errors)
	}

	return nil
}

// PageListStatisticResponseMultiError is an error wrapping multiple validation
// errors returned by PageListStatisticResponse.ValidateAll() if the
// designated constraints aren't met.
type PageListStatisticResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListStatisticResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListStatisticResponseMultiError) AllErrors() []error { return m }

// PageListStatisticResponseValidationError is the validation error returned by
// PageListStatisticResponse.Validate if the designated constraints aren't met.
type PageListStatisticResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListStatisticResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListStatisticResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListStatisticResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListStatisticResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListStatisticResponseValidationError) ErrorName() string {
	return "PageListStatisticResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PageListStatisticResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListStatisticResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListStatisticResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListStatisticResponseValidationError{}

// Validate checks the field values on StatisticResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StatisticResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatisticResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatisticResponseMultiError, or nil if none found.
func (m *StatisticResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StatisticResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ChainName

	// no validation rules for TokenAddress

	// no validation rules for FundDirection

	// no validation rules for FundType

	// no validation rules for TransactionQuantity

	// no validation rules for Amount

	// no validation rules for CnyAmount

	// no validation rules for UsdAmount

	// no validation rules for Dt

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for Cursor

	if len(errors) > 0 {
		return StatisticResponseMultiError(errors)
	}

	return nil
}

// StatisticResponseMultiError is an error wrapping multiple validation errors
// returned by StatisticResponse.ValidateAll() if the designated constraints
// aren't met.
type StatisticResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatisticResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatisticResponseMultiError) AllErrors() []error { return m }

// StatisticResponseValidationError is the validation error returned by
// StatisticResponse.Validate if the designated constraints aren't met.
type StatisticResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatisticResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatisticResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatisticResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatisticResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatisticResponseValidationError) ErrorName() string {
	return "StatisticResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StatisticResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatisticResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatisticResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatisticResponseValidationError{}

// Validate checks the field values on StatisticFundRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StatisticFundRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatisticFundRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatisticFundRequestMultiError, or nil if none found.
func (m *StatisticFundRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatisticFundRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	if m.GetStartTime() <= 0 {
		err := StatisticFundRequestValidationError{
			field:  "StartTime",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStopTime() <= 0 {
		err := StatisticFundRequestValidationError{
			field:  "StopTime",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return StatisticFundRequestMultiError(errors)
	}

	return nil
}

// StatisticFundRequestMultiError is an error wrapping multiple validation
// errors returned by StatisticFundRequest.ValidateAll() if the designated
// constraints aren't met.
type StatisticFundRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatisticFundRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatisticFundRequestMultiError) AllErrors() []error { return m }

// StatisticFundRequestValidationError is the validation error returned by
// StatisticFundRequest.Validate if the designated constraints aren't met.
type StatisticFundRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatisticFundRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatisticFundRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatisticFundRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatisticFundRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatisticFundRequestValidationError) ErrorName() string {
	return "StatisticFundRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StatisticFundRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatisticFundRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatisticFundRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatisticFundRequestValidationError{}

// Validate checks the field values on FundAmountListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FundAmountListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FundAmountListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FundAmountListResponseMultiError, or nil if none found.
func (m *FundAmountListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FundAmountListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FundAmountListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FundAmountListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FundAmountListResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FundAmountListResponseMultiError(errors)
	}

	return nil
}

// FundAmountListResponseMultiError is an error wrapping multiple validation
// errors returned by FundAmountListResponse.ValidateAll() if the designated
// constraints aren't met.
type FundAmountListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FundAmountListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FundAmountListResponseMultiError) AllErrors() []error { return m }

// FundAmountListResponseValidationError is the validation error returned by
// FundAmountListResponse.Validate if the designated constraints aren't met.
type FundAmountListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FundAmountListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FundAmountListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FundAmountListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FundAmountListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FundAmountListResponseValidationError) ErrorName() string {
	return "FundAmountListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FundAmountListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFundAmountListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FundAmountListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FundAmountListResponseValidationError{}

// Validate checks the field values on FundAmountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FundAmountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FundAmountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FundAmountResponseMultiError, or nil if none found.
func (m *FundAmountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FundAmountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FundDirection

	// no validation rules for TransactionQuantity

	// no validation rules for Amount

	// no validation rules for CnyAmount

	// no validation rules for UsdAmount

	// no validation rules for Dt

	if len(errors) > 0 {
		return FundAmountResponseMultiError(errors)
	}

	return nil
}

// FundAmountResponseMultiError is an error wrapping multiple validation errors
// returned by FundAmountResponse.ValidateAll() if the designated constraints
// aren't met.
type FundAmountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FundAmountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FundAmountResponseMultiError) AllErrors() []error { return m }

// FundAmountResponseValidationError is the validation error returned by
// FundAmountResponse.Validate if the designated constraints aren't met.
type FundAmountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FundAmountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FundAmountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FundAmountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FundAmountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FundAmountResponseValidationError) ErrorName() string {
	return "FundAmountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FundAmountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFundAmountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FundAmountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FundAmountResponseValidationError{}

// Validate checks the field values on FundRateListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FundRateListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FundRateListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FundRateListResponseMultiError, or nil if none found.
func (m *FundRateListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FundRateListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FundRateListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FundRateListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FundRateListResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FundRateListResponseMultiError(errors)
	}

	return nil
}

// FundRateListResponseMultiError is an error wrapping multiple validation
// errors returned by FundRateListResponse.ValidateAll() if the designated
// constraints aren't met.
type FundRateListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FundRateListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FundRateListResponseMultiError) AllErrors() []error { return m }

// FundRateListResponseValidationError is the validation error returned by
// FundRateListResponse.Validate if the designated constraints aren't met.
type FundRateListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FundRateListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FundRateListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FundRateListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FundRateListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FundRateListResponseValidationError) ErrorName() string {
	return "FundRateListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FundRateListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFundRateListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FundRateListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FundRateListResponseValidationError{}

// Validate checks the field values on FundRateResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FundRateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FundRateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FundRateResponseMultiError, or nil if none found.
func (m *FundRateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FundRateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FundDirection

	// no validation rules for FundType

	// no validation rules for TransactionQuantity

	// no validation rules for Amount

	// no validation rules for CnyAmount

	// no validation rules for UsdAmount

	// no validation rules for Rate

	if len(errors) > 0 {
		return FundRateResponseMultiError(errors)
	}

	return nil
}

// FundRateResponseMultiError is an error wrapping multiple validation errors
// returned by FundRateResponse.ValidateAll() if the designated constraints
// aren't met.
type FundRateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FundRateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FundRateResponseMultiError) AllErrors() []error { return m }

// FundRateResponseValidationError is the validation error returned by
// FundRateResponse.Validate if the designated constraints aren't met.
type FundRateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FundRateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FundRateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FundRateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FundRateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FundRateResponseValidationError) ErrorName() string { return "FundRateResponseValidationError" }

// Error satisfies the builtin error interface
func (e FundRateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFundRateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FundRateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FundRateResponseValidationError{}

// Validate checks the field values on KanbanSummaryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KanbanSummaryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KanbanSummaryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KanbanSummaryRequestMultiError, or nil if none found.
func (m *KanbanSummaryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *KanbanSummaryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for Address

	// no validation rules for Uid

	if len(errors) > 0 {
		return KanbanSummaryRequestMultiError(errors)
	}

	return nil
}

// KanbanSummaryRequestMultiError is an error wrapping multiple validation
// errors returned by KanbanSummaryRequest.ValidateAll() if the designated
// constraints aren't met.
type KanbanSummaryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KanbanSummaryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KanbanSummaryRequestMultiError) AllErrors() []error { return m }

// KanbanSummaryRequestValidationError is the validation error returned by
// KanbanSummaryRequest.Validate if the designated constraints aren't met.
type KanbanSummaryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KanbanSummaryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KanbanSummaryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KanbanSummaryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KanbanSummaryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KanbanSummaryRequestValidationError) ErrorName() string {
	return "KanbanSummaryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e KanbanSummaryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKanbanSummaryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KanbanSummaryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KanbanSummaryRequestValidationError{}

// Validate checks the field values on KanbanRank with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KanbanRank) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KanbanRank with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KanbanRankMultiError, or
// nil if none found.
func (m *KanbanRank) ValidateAll() error {
	return m.validate(true)
}

func (m *KanbanRank) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TopPercent

	// no validation rules for LowerBound

	if len(errors) > 0 {
		return KanbanRankMultiError(errors)
	}

	return nil
}

// KanbanRankMultiError is an error wrapping multiple validation errors
// returned by KanbanRank.ValidateAll() if the designated constraints aren't met.
type KanbanRankMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KanbanRankMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KanbanRankMultiError) AllErrors() []error { return m }

// KanbanRankValidationError is the validation error returned by
// KanbanRank.Validate if the designated constraints aren't met.
type KanbanRankValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KanbanRankValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KanbanRankValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KanbanRankValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KanbanRankValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KanbanRankValidationError) ErrorName() string { return "KanbanRankValidationError" }

// Error satisfies the builtin error interface
func (e KanbanRankValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKanbanRank.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KanbanRankValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KanbanRankValidationError{}

// Validate checks the field values on KanbanTopPercent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *KanbanTopPercent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KanbanTopPercent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KanbanTopPercentMultiError, or nil if none found.
func (m *KanbanTopPercent) ValidateAll() error {
	return m.validate(true)
}

func (m *KanbanTopPercent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalTx

	// no validation rules for TotalTxAmount

	// no validation rules for TotalContract

	// no validation rules for TotalTxInAmount

	if len(errors) > 0 {
		return KanbanTopPercentMultiError(errors)
	}

	return nil
}

// KanbanTopPercentMultiError is an error wrapping multiple validation errors
// returned by KanbanTopPercent.ValidateAll() if the designated constraints
// aren't met.
type KanbanTopPercentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KanbanTopPercentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KanbanTopPercentMultiError) AllErrors() []error { return m }

// KanbanTopPercentValidationError is the validation error returned by
// KanbanTopPercent.Validate if the designated constraints aren't met.
type KanbanTopPercentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KanbanTopPercentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KanbanTopPercentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KanbanTopPercentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KanbanTopPercentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KanbanTopPercentValidationError) ErrorName() string { return "KanbanTopPercentValidationError" }

// Error satisfies the builtin error interface
func (e KanbanTopPercentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKanbanTopPercent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KanbanTopPercentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KanbanTopPercentValidationError{}

// Validate checks the field values on KanbanSummaryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KanbanSummaryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KanbanSummaryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KanbanSummaryResponseMultiError, or nil if none found.
func (m *KanbanSummaryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *KanbanSummaryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FirstTxTime

	// no validation rules for TotalTxNum

	// no validation rules for TotalTxAmount

	// no validation rules for TotalContract

	// no validation rules for TotalTxInAmount

	for idx, item := range m.GetTotalTxsRanks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KanbanSummaryResponseValidationError{
						field:  fmt.Sprintf("TotalTxsRanks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KanbanSummaryResponseValidationError{
						field:  fmt.Sprintf("TotalTxsRanks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KanbanSummaryResponseValidationError{
					field:  fmt.Sprintf("TotalTxsRanks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTotalTxAmountRanks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KanbanSummaryResponseValidationError{
						field:  fmt.Sprintf("TotalTxAmountRanks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KanbanSummaryResponseValidationError{
						field:  fmt.Sprintf("TotalTxAmountRanks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KanbanSummaryResponseValidationError{
					field:  fmt.Sprintf("TotalTxAmountRanks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTotalContractRanks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KanbanSummaryResponseValidationError{
						field:  fmt.Sprintf("TotalContractRanks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KanbanSummaryResponseValidationError{
						field:  fmt.Sprintf("TotalContractRanks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KanbanSummaryResponseValidationError{
					field:  fmt.Sprintf("TotalContractRanks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTotalTxInAmountRanks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KanbanSummaryResponseValidationError{
						field:  fmt.Sprintf("TotalTxInAmountRanks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KanbanSummaryResponseValidationError{
						field:  fmt.Sprintf("TotalTxInAmountRanks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KanbanSummaryResponseValidationError{
					field:  fmt.Sprintf("TotalTxInAmountRanks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.TopPercents != nil {

		if all {
			switch v := interface{}(m.GetTopPercents()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KanbanSummaryResponseValidationError{
						field:  "TopPercents",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KanbanSummaryResponseValidationError{
						field:  "TopPercents",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTopPercents()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KanbanSummaryResponseValidationError{
					field:  "TopPercents",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return KanbanSummaryResponseMultiError(errors)
	}

	return nil
}

// KanbanSummaryResponseMultiError is an error wrapping multiple validation
// errors returned by KanbanSummaryResponse.ValidateAll() if the designated
// constraints aren't met.
type KanbanSummaryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KanbanSummaryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KanbanSummaryResponseMultiError) AllErrors() []error { return m }

// KanbanSummaryResponseValidationError is the validation error returned by
// KanbanSummaryResponse.Validate if the designated constraints aren't met.
type KanbanSummaryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KanbanSummaryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KanbanSummaryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KanbanSummaryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KanbanSummaryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KanbanSummaryResponseValidationError) ErrorName() string {
	return "KanbanSummaryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e KanbanSummaryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKanbanSummaryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KanbanSummaryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KanbanSummaryResponseValidationError{}

// Validate checks the field values on KanbanChartRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KanbanChartRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KanbanChartRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KanbanChartRequestMultiError, or nil if none found.
func (m *KanbanChartRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *KanbanChartRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for Address

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for Uid

	if len(errors) > 0 {
		return KanbanChartRequestMultiError(errors)
	}

	return nil
}

// KanbanChartRequestMultiError is an error wrapping multiple validation errors
// returned by KanbanChartRequest.ValidateAll() if the designated constraints
// aren't met.
type KanbanChartRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KanbanChartRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KanbanChartRequestMultiError) AllErrors() []error { return m }

// KanbanChartRequestValidationError is the validation error returned by
// KanbanChartRequest.Validate if the designated constraints aren't met.
type KanbanChartRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KanbanChartRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KanbanChartRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KanbanChartRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KanbanChartRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KanbanChartRequestValidationError) ErrorName() string {
	return "KanbanChartRequestValidationError"
}

// Error satisfies the builtin error interface
func (e KanbanChartRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKanbanChartRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KanbanChartRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KanbanChartRequestValidationError{}

// Validate checks the field values on KanbanBar with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KanbanBar) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KanbanBar with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KanbanBarMultiError, or nil
// if none found.
func (m *KanbanBar) ValidateAll() error {
	return m.validate(true)
}

func (m *KanbanBar) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Time

	// no validation rules for Value

	if len(errors) > 0 {
		return KanbanBarMultiError(errors)
	}

	return nil
}

// KanbanBarMultiError is an error wrapping multiple validation errors returned
// by KanbanBar.ValidateAll() if the designated constraints aren't met.
type KanbanBarMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KanbanBarMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KanbanBarMultiError) AllErrors() []error { return m }

// KanbanBarValidationError is the validation error returned by
// KanbanBar.Validate if the designated constraints aren't met.
type KanbanBarValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KanbanBarValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KanbanBarValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KanbanBarValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KanbanBarValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KanbanBarValidationError) ErrorName() string { return "KanbanBarValidationError" }

// Error satisfies the builtin error interface
func (e KanbanBarValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKanbanBar.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KanbanBarValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KanbanBarValidationError{}

// Validate checks the field values on KanbanChartResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KanbanChartResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KanbanChartResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KanbanChartResponseMultiError, or nil if none found.
func (m *KanbanChartResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *KanbanChartResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNumsByDay() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KanbanChartResponseValidationError{
						field:  fmt.Sprintf("NumsByDay[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KanbanChartResponseValidationError{
						field:  fmt.Sprintf("NumsByDay[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KanbanChartResponseValidationError{
					field:  fmt.Sprintf("NumsByDay[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAccumulatedNums() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KanbanChartResponseValidationError{
						field:  fmt.Sprintf("AccumulatedNums[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KanbanChartResponseValidationError{
						field:  fmt.Sprintf("AccumulatedNums[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KanbanChartResponseValidationError{
					field:  fmt.Sprintf("AccumulatedNums[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return KanbanChartResponseMultiError(errors)
	}

	return nil
}

// KanbanChartResponseMultiError is an error wrapping multiple validation
// errors returned by KanbanChartResponse.ValidateAll() if the designated
// constraints aren't met.
type KanbanChartResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KanbanChartResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KanbanChartResponseMultiError) AllErrors() []error { return m }

// KanbanChartResponseValidationError is the validation error returned by
// KanbanChartResponse.Validate if the designated constraints aren't met.
type KanbanChartResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KanbanChartResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KanbanChartResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KanbanChartResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KanbanChartResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KanbanChartResponseValidationError) ErrorName() string {
	return "KanbanChartResponseValidationError"
}

// Error satisfies the builtin error interface
func (e KanbanChartResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKanbanChartResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KanbanChartResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KanbanChartResponseValidationError{}
