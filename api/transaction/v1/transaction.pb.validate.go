// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/transaction/v1/transaction.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on DappPageListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DappPageListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappPageListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DappPageListReqMultiError, or nil if none found.
func (m *DappPageListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DappPageListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for ContractAddress

	// no validation rules for Page

	// no validation rules for Limit

	// no validation rules for Fromuid

	// no validation rules for FromAddress

	if len(errors) > 0 {
		return DappPageListReqMultiError(errors)
	}

	return nil
}

// DappPageListReqMultiError is an error wrapping multiple validation errors
// returned by DappPageListReq.ValidateAll() if the designated constraints
// aren't met.
type DappPageListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappPageListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappPageListReqMultiError) AllErrors() []error { return m }

// DappPageListReqValidationError is the validation error returned by
// DappPageListReq.Validate if the designated constraints aren't met.
type DappPageListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappPageListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappPageListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappPageListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappPageListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappPageListReqValidationError) ErrorName() string { return "DappPageListReqValidationError" }

// Error satisfies the builtin error interface
func (e DappPageListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappPageListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappPageListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappPageListReqValidationError{}

// Validate checks the field values on DappPageListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DappPageListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappPageListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DappPageListRespMultiError, or nil if none found.
func (m *DappPageListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DappPageListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DappPageListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DappPageListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DappPageListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DappPageListRespMultiError(errors)
	}

	return nil
}

// DappPageListRespMultiError is an error wrapping multiple validation errors
// returned by DappPageListResp.ValidateAll() if the designated constraints
// aren't met.
type DappPageListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappPageListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappPageListRespMultiError) AllErrors() []error { return m }

// DappPageListRespValidationError is the validation error returned by
// DappPageListResp.Validate if the designated constraints aren't met.
type DappPageListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappPageListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappPageListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappPageListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappPageListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappPageListRespValidationError) ErrorName() string { return "DappPageListRespValidationError" }

// Error satisfies the builtin error interface
func (e DappPageListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappPageListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappPageListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappPageListRespValidationError{}

// Validate checks the field values on DappPageData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DappPageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappPageData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DappPageDataMultiError, or
// nil if none found.
func (m *DappPageData) ValidateAll() error {
	return m.validate(true)
}

func (m *DappPageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Limit

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DappPageDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DappPageDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DappPageDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DappPageDataMultiError(errors)
	}

	return nil
}

// DappPageDataMultiError is an error wrapping multiple validation errors
// returned by DappPageData.ValidateAll() if the designated constraints aren't met.
type DappPageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappPageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappPageDataMultiError) AllErrors() []error { return m }

// DappPageDataValidationError is the validation error returned by
// DappPageData.Validate if the designated constraints aren't met.
type DappPageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappPageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappPageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappPageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappPageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappPageDataValidationError) ErrorName() string { return "DappPageDataValidationError" }

// Error satisfies the builtin error interface
func (e DappPageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappPageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappPageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappPageDataValidationError{}

// Validate checks the field values on NonceReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NonceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NonceReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NonceReqMultiError, or nil
// if none found.
func (m *NonceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *NonceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChainName()) < 1 {
		err := NonceReqValidationError{
			field:  "ChainName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAddress()) < 1 {
		err := NonceReqValidationError{
			field:  "Address",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return NonceReqMultiError(errors)
	}

	return nil
}

// NonceReqMultiError is an error wrapping multiple validation errors returned
// by NonceReq.ValidateAll() if the designated constraints aren't met.
type NonceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NonceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NonceReqMultiError) AllErrors() []error { return m }

// NonceReqValidationError is the validation error returned by
// NonceReq.Validate if the designated constraints aren't met.
type NonceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NonceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NonceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NonceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NonceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NonceReqValidationError) ErrorName() string { return "NonceReqValidationError" }

// Error satisfies the builtin error interface
func (e NonceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNonceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NonceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NonceReqValidationError{}

// Validate checks the field values on NonceResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NonceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NonceResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NonceRespMultiError, or nil
// if none found.
func (m *NonceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *NonceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	// no validation rules for Nonce

	if len(errors) > 0 {
		return NonceRespMultiError(errors)
	}

	return nil
}

// NonceRespMultiError is an error wrapping multiple validation errors returned
// by NonceResp.ValidateAll() if the designated constraints aren't met.
type NonceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NonceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NonceRespMultiError) AllErrors() []error { return m }

// NonceRespValidationError is the validation error returned by
// NonceResp.Validate if the designated constraints aren't met.
type NonceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NonceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NonceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NonceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NonceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NonceRespValidationError) ErrorName() string { return "NonceRespValidationError" }

// Error satisfies the builtin error interface
func (e NonceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNonceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NonceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NonceRespValidationError{}

// Validate checks the field values on OpenAmountReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenAmountReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAmountReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpenAmountReqMultiError, or
// nil if none found.
func (m *OpenAmountReq) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAmountReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Currency

	// no validation rules for ChainName

	// no validation rules for Address

	// no validation rules for ContractAddress

	if len(errors) > 0 {
		return OpenAmountReqMultiError(errors)
	}

	return nil
}

// OpenAmountReqMultiError is an error wrapping multiple validation errors
// returned by OpenAmountReq.ValidateAll() if the designated constraints
// aren't met.
type OpenAmountReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAmountReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAmountReqMultiError) AllErrors() []error { return m }

// OpenAmountReqValidationError is the validation error returned by
// OpenAmountReq.Validate if the designated constraints aren't met.
type OpenAmountReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAmountReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAmountReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAmountReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAmountReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAmountReqValidationError) ErrorName() string { return "OpenAmountReqValidationError" }

// Error satisfies the builtin error interface
func (e OpenAmountReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAmountReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAmountReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAmountReqValidationError{}

// Validate checks the field values on OpenAmoutResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenAmoutResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAmoutResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpenAmoutRespMultiError, or
// nil if none found.
func (m *OpenAmoutResp) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAmoutResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OpenAmoutRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OpenAmoutRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OpenAmoutRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OpenAmoutRespMultiError(errors)
	}

	return nil
}

// OpenAmoutRespMultiError is an error wrapping multiple validation errors
// returned by OpenAmoutResp.ValidateAll() if the designated constraints
// aren't met.
type OpenAmoutRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAmoutRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAmoutRespMultiError) AllErrors() []error { return m }

// OpenAmoutRespValidationError is the validation error returned by
// OpenAmoutResp.Validate if the designated constraints aren't met.
type OpenAmoutRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAmoutRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAmoutRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAmoutRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAmoutRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAmoutRespValidationError) ErrorName() string { return "OpenAmoutRespValidationError" }

// Error satisfies the builtin error interface
func (e OpenAmoutRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAmoutResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAmoutRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAmoutRespValidationError{}

// Validate checks the field values on OpenAmountInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenAmountInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAmountInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpenAmountInfoMultiError,
// or nil if none found.
func (m *OpenAmountInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAmountInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RiskExposureAmount

	// no validation rules for DappCount

	if len(errors) > 0 {
		return OpenAmountInfoMultiError(errors)
	}

	return nil
}

// OpenAmountInfoMultiError is an error wrapping multiple validation errors
// returned by OpenAmountInfo.ValidateAll() if the designated constraints
// aren't met.
type OpenAmountInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAmountInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAmountInfoMultiError) AllErrors() []error { return m }

// OpenAmountInfoValidationError is the validation error returned by
// OpenAmountInfo.Validate if the designated constraints aren't met.
type OpenAmountInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAmountInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAmountInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAmountInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAmountInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAmountInfoValidationError) ErrorName() string { return "OpenAmountInfoValidationError" }

// Error satisfies the builtin error interface
func (e OpenAmountInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAmountInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAmountInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAmountInfoValidationError{}

// Validate checks the field values on DappListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DappListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DappListReqMultiError, or
// nil if none found.
func (m *DappListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DappListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for ChainName

	// no validation rules for ContractAddress

	// no validation rules for IsCancel

	// no validation rules for IsCancelStatus

	if len(errors) > 0 {
		return DappListReqMultiError(errors)
	}

	return nil
}

// DappListReqMultiError is an error wrapping multiple validation errors
// returned by DappListReq.ValidateAll() if the designated constraints aren't met.
type DappListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappListReqMultiError) AllErrors() []error { return m }

// DappListReqValidationError is the validation error returned by
// DappListReq.Validate if the designated constraints aren't met.
type DappListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappListReqValidationError) ErrorName() string { return "DappListReqValidationError" }

// Error satisfies the builtin error interface
func (e DappListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappListReqValidationError{}

// Validate checks the field values on DappListResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DappListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DappListRespMultiError, or
// nil if none found.
func (m *DappListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DappListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DappListRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DappListRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DappListRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DappListRespMultiError(errors)
	}

	return nil
}

// DappListRespMultiError is an error wrapping multiple validation errors
// returned by DappListResp.ValidateAll() if the designated constraints aren't met.
type DappListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappListRespMultiError) AllErrors() []error { return m }

// DappListRespValidationError is the validation error returned by
// DappListResp.Validate if the designated constraints aren't met.
type DappListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappListRespValidationError) ErrorName() string { return "DappListRespValidationError" }

// Error satisfies the builtin error interface
func (e DappListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappListRespValidationError{}

// Validate checks the field values on DappInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DappInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DappInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DappInfoMultiError, or nil
// if none found.
func (m *DappInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DappInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContractAddress

	// no validation rules for Chain

	// no validation rules for Uid

	// no validation rules for LastTxhash

	// no validation rules for Decimals

	// no validation rules for Address

	// no validation rules for Token

	// no validation rules for ToAddress

	// no validation rules for Amount

	// no validation rules for Original

	// no validation rules for Symbol

	// no validation rules for DappInfo

	// no validation rules for Status

	if len(errors) > 0 {
		return DappInfoMultiError(errors)
	}

	return nil
}

// DappInfoMultiError is an error wrapping multiple validation errors returned
// by DappInfo.ValidateAll() if the designated constraints aren't met.
type DappInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DappInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DappInfoMultiError) AllErrors() []error { return m }

// DappInfoValidationError is the validation error returned by
// DappInfo.Validate if the designated constraints aren't met.
type DappInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DappInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DappInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DappInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DappInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DappInfoValidationError) ErrorName() string { return "DappInfoValidationError" }

// Error satisfies the builtin error interface
func (e DappInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDappInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DappInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DappInfoValidationError{}

// Validate checks the field values on CreateResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateResponseMultiError,
// or nil if none found.
func (m *CreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Code

	// no validation rules for Mes

	if len(errors) > 0 {
		return CreateResponseMultiError(errors)
	}

	return nil
}

// CreateResponseMultiError is an error wrapping multiple validation errors
// returned by CreateResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateResponseMultiError) AllErrors() []error { return m }

// CreateResponseValidationError is the validation error returned by
// CreateResponse.Validate if the designated constraints aren't met.
type CreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateResponseValidationError) ErrorName() string { return "CreateResponseValidationError" }

// Error satisfies the builtin error interface
func (e CreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateResponseValidationError{}

// Validate checks the field values on TransactionReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransactionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransactionReqMultiError,
// or nil if none found.
func (m *TransactionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if utf8.RuneCountInString(m.GetChainName()) < 1 {
		err := TransactionReqValidationError{
			field:  "ChainName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTransactionHash()) < 1 {
		err := TransactionReqValidationError{
			field:  "TransactionHash",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetStatus()) < 1 {
		err := TransactionReqValidationError{
			field:  "Status",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFromAddress()) < 1 {
		err := TransactionReqValidationError{
			field:  "FromAddress",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ToAddress

	// no validation rules for Amount

	// no validation rules for FeeAmount

	// no validation rules for TransactionType

	// no validation rules for ContractAddress

	// no validation rules for TxTime

	// no validation rules for Nonce

	// no validation rules for GasLimit

	// no validation rules for GasUsed

	// no validation rules for GasPrice

	// no validation rules for BaseFee

	// no validation rules for Data

	// no validation rules for DappData

	// no validation rules for EventLog

	// no validation rules for ParseData

	// no validation rules for NetUsage

	// no validation rules for FeeLimit

	// no validation rules for EnergyUsage

	// no validation rules for BlockHash

	// no validation rules for BlockNumber

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for ClientData

	// no validation rules for MaxFeePerGas

	// no validation rules for MaxPriorityFeePerGas

	// no validation rules for FeeData

	if len(errors) > 0 {
		return TransactionReqMultiError(errors)
	}

	return nil
}

// TransactionReqMultiError is an error wrapping multiple validation errors
// returned by TransactionReq.ValidateAll() if the designated constraints
// aren't met.
type TransactionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionReqMultiError) AllErrors() []error { return m }

// TransactionReqValidationError is the validation error returned by
// TransactionReq.Validate if the designated constraints aren't met.
type TransactionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionReqValidationError) ErrorName() string { return "TransactionReqValidationError" }

// Error satisfies the builtin error interface
func (e TransactionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionReqValidationError{}

// Validate checks the field values on PageListRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PageListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListRequestMultiError, or nil if none found.
func (m *PageListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChainName()) < 1 {
		err := PageListRequestValidationError{
			field:  "ChainName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FromUid

	// no validation rules for ToUid

	// no validation rules for Uid

	// no validation rules for Address

	// no validation rules for ContractAddress

	if m.GetStartTime() < 0 {
		err := PageListRequestValidationError{
			field:  "StartTime",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStopTime() < 0 {
		err := PageListRequestValidationError{
			field:  "StopTime",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OrderBy

	if _, ok := _PageListRequest_DataDirection_InLookup[m.GetDataDirection()]; !ok {
		err := PageListRequestValidationError{
			field:  "DataDirection",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStartIndex() < 0 {
		err := PageListRequestValidationError{
			field:  "StartIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := PageListRequestValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() < 0 {
		err := PageListRequestValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Total

	// no validation rules for Platform

	if len(errors) > 0 {
		return PageListRequestMultiError(errors)
	}

	return nil
}

// PageListRequestMultiError is an error wrapping multiple validation errors
// returned by PageListRequest.ValidateAll() if the designated constraints
// aren't met.
type PageListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListRequestMultiError) AllErrors() []error { return m }

// PageListRequestValidationError is the validation error returned by
// PageListRequest.Validate if the designated constraints aren't met.
type PageListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListRequestValidationError) ErrorName() string { return "PageListRequestValidationError" }

// Error satisfies the builtin error interface
func (e PageListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListRequestValidationError{}

var _PageListRequest_DataDirection_InLookup = map[int32]struct{}{
	0: {},
	1: {},
	2: {},
}

// Validate checks the field values on PageListResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PageListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageListResponseMultiError, or nil if none found.
func (m *PageListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PageListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PageListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PageListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PageListResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PageListResponseMultiError(errors)
	}

	return nil
}

// PageListResponseMultiError is an error wrapping multiple validation errors
// returned by PageListResponse.ValidateAll() if the designated constraints
// aren't met.
type PageListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageListResponseMultiError) AllErrors() []error { return m }

// PageListResponseValidationError is the validation error returned by
// PageListResponse.Validate if the designated constraints aren't met.
type PageListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageListResponseValidationError) ErrorName() string { return "PageListResponseValidationError" }

// Error satisfies the builtin error interface
func (e PageListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageListResponseValidationError{}

// Validate checks the field values on TransactionRecord with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransactionRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionRecordMultiError, or nil if none found.
func (m *TransactionRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ChainName

	// no validation rules for BlockHash

	// no validation rules for BlockNumber

	// no validation rules for TransactionHash

	// no validation rules for FromAddress

	// no validation rules for ToAddress

	// no validation rules for FromUid

	// no validation rules for ToUid

	// no validation rules for Amount

	// no validation rules for FeeAmount

	// no validation rules for Status

	// no validation rules for TransactionType

	// no validation rules for ContractAddress

	// no validation rules for TxTime

	// no validation rules for Nonce

	// no validation rules for GasLimit

	// no validation rules for GasUsed

	// no validation rules for GasPrice

	// no validation rules for BaseFee

	// no validation rules for MaxFeePerGas

	// no validation rules for MaxPriorityFeePerGas

	// no validation rules for Data

	// no validation rules for DappData

	// no validation rules for EventLog

	// no validation rules for ParseData

	// no validation rules for NetUsage

	// no validation rules for FeeLimit

	// no validation rules for EnergyUsage

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for ClientData

	// no validation rules for FeeData

	// no validation rules for Cursor

	if len(errors) > 0 {
		return TransactionRecordMultiError(errors)
	}

	return nil
}

// TransactionRecordMultiError is an error wrapping multiple validation errors
// returned by TransactionRecord.ValidateAll() if the designated constraints
// aren't met.
type TransactionRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionRecordMultiError) AllErrors() []error { return m }

// TransactionRecordValidationError is the validation error returned by
// TransactionRecord.Validate if the designated constraints aren't met.
type TransactionRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionRecordValidationError) ErrorName() string {
	return "TransactionRecordValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionRecordValidationError{}

// Validate checks the field values on AmountRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AmountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmountRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AmountRequestMultiError, or
// nil if none found.
func (m *AmountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AmountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChainName()) < 1 {
		err := AmountRequestValidationError{
			field:  "ChainName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FromUid

	// no validation rules for ToUid

	if len(errors) > 0 {
		return AmountRequestMultiError(errors)
	}

	return nil
}

// AmountRequestMultiError is an error wrapping multiple validation errors
// returned by AmountRequest.ValidateAll() if the designated constraints
// aren't met.
type AmountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmountRequestMultiError) AllErrors() []error { return m }

// AmountRequestValidationError is the validation error returned by
// AmountRequest.Validate if the designated constraints aren't met.
type AmountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmountRequestValidationError) ErrorName() string { return "AmountRequestValidationError" }

// Error satisfies the builtin error interface
func (e AmountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmountRequestValidationError{}

// Validate checks the field values on AmountResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AmountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmountResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AmountResponseMultiError,
// or nil if none found.
func (m *AmountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AmountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Amount

	if len(errors) > 0 {
		return AmountResponseMultiError(errors)
	}

	return nil
}

// AmountResponseMultiError is an error wrapping multiple validation errors
// returned by AmountResponse.ValidateAll() if the designated constraints
// aren't met.
type AmountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmountResponseMultiError) AllErrors() []error { return m }

// AmountResponseValidationError is the validation error returned by
// AmountResponse.Validate if the designated constraints aren't met.
type AmountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmountResponseValidationError) ErrorName() string { return "AmountResponseValidationError" }

// Error satisfies the builtin error interface
func (e AmountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmountResponseValidationError{}

// Validate checks the field values on AssetRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetRequestMultiError, or
// nil if none found.
func (m *AssetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for Uid

	if _, ok := _AssetRequest_Currency_InLookup[m.GetCurrency()]; !ok {
		err := AssetRequestValidationError{
			field:  "Currency",
			reason: "value must be in list [CNY USD]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OrderBy

	if _, ok := _AssetRequest_DataDirection_InLookup[m.GetDataDirection()]; !ok {
		err := AssetRequestValidationError{
			field:  "DataDirection",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStartIndex() < 0 {
		err := AssetRequestValidationError{
			field:  "StartIndex",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := AssetRequestValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() < 0 {
		err := AssetRequestValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Total

	if len(errors) > 0 {
		return AssetRequestMultiError(errors)
	}

	return nil
}

// AssetRequestMultiError is an error wrapping multiple validation errors
// returned by AssetRequest.ValidateAll() if the designated constraints aren't met.
type AssetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetRequestMultiError) AllErrors() []error { return m }

// AssetRequestValidationError is the validation error returned by
// AssetRequest.Validate if the designated constraints aren't met.
type AssetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetRequestValidationError) ErrorName() string { return "AssetRequestValidationError" }

// Error satisfies the builtin error interface
func (e AssetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetRequestValidationError{}

var _AssetRequest_Currency_InLookup = map[string]struct{}{
	"CNY": {},
	"USD": {},
}

var _AssetRequest_DataDirection_InLookup = map[int32]struct{}{
	0: {},
	1: {},
	2: {},
}

// Validate checks the field values on AssetPageListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AssetPageListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetPageListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssetPageListResponseMultiError, or nil if none found.
func (m *AssetPageListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetPageListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	// no validation rules for TotalCurrencyAmount

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetPageListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetPageListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetPageListResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AssetPageListResponseMultiError(errors)
	}

	return nil
}

// AssetPageListResponseMultiError is an error wrapping multiple validation
// errors returned by AssetPageListResponse.ValidateAll() if the designated
// constraints aren't met.
type AssetPageListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetPageListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetPageListResponseMultiError) AllErrors() []error { return m }

// AssetPageListResponseValidationError is the validation error returned by
// AssetPageListResponse.Validate if the designated constraints aren't met.
type AssetPageListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetPageListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetPageListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetPageListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetPageListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetPageListResponseValidationError) ErrorName() string {
	return "AssetPageListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AssetPageListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetPageListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetPageListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetPageListResponseValidationError{}

// Validate checks the field values on AssetResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetResponseMultiError, or
// nil if none found.
func (m *AssetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	// no validation rules for Uid

	// no validation rules for Address

	// no validation rules for TokenAddress

	// no validation rules for Amount

	// no validation rules for Decimals

	// no validation rules for Symbol

	// no validation rules for CurrencyAmount

	if len(errors) > 0 {
		return AssetResponseMultiError(errors)
	}

	return nil
}

// AssetResponseMultiError is an error wrapping multiple validation errors
// returned by AssetResponse.ValidateAll() if the designated constraints
// aren't met.
type AssetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetResponseMultiError) AllErrors() []error { return m }

// AssetResponseValidationError is the validation error returned by
// AssetResponse.Validate if the designated constraints aren't met.
type AssetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetResponseValidationError) ErrorName() string { return "AssetResponseValidationError" }

// Error satisfies the builtin error interface
func (e AssetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetResponseValidationError{}

// Validate checks the field values on StatisticFundRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StatisticFundRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatisticFundRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatisticFundRequestMultiError, or nil if none found.
func (m *StatisticFundRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatisticFundRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainName

	if m.GetStartTime() <= 0 {
		err := StatisticFundRequestValidationError{
			field:  "StartTime",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStopTime() <= 0 {
		err := StatisticFundRequestValidationError{
			field:  "StopTime",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return StatisticFundRequestMultiError(errors)
	}

	return nil
}

// StatisticFundRequestMultiError is an error wrapping multiple validation
// errors returned by StatisticFundRequest.ValidateAll() if the designated
// constraints aren't met.
type StatisticFundRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatisticFundRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatisticFundRequestMultiError) AllErrors() []error { return m }

// StatisticFundRequestValidationError is the validation error returned by
// StatisticFundRequest.Validate if the designated constraints aren't met.
type StatisticFundRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatisticFundRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatisticFundRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatisticFundRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatisticFundRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatisticFundRequestValidationError) ErrorName() string {
	return "StatisticFundRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StatisticFundRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatisticFundRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatisticFundRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatisticFundRequestValidationError{}

// Validate checks the field values on FundAmountListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FundAmountListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FundAmountListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FundAmountListResponseMultiError, or nil if none found.
func (m *FundAmountListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FundAmountListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FundAmountListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FundAmountListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FundAmountListResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FundAmountListResponseMultiError(errors)
	}

	return nil
}

// FundAmountListResponseMultiError is an error wrapping multiple validation
// errors returned by FundAmountListResponse.ValidateAll() if the designated
// constraints aren't met.
type FundAmountListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FundAmountListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FundAmountListResponseMultiError) AllErrors() []error { return m }

// FundAmountListResponseValidationError is the validation error returned by
// FundAmountListResponse.Validate if the designated constraints aren't met.
type FundAmountListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FundAmountListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FundAmountListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FundAmountListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FundAmountListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FundAmountListResponseValidationError) ErrorName() string {
	return "FundAmountListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FundAmountListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFundAmountListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FundAmountListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FundAmountListResponseValidationError{}

// Validate checks the field values on FundAmountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FundAmountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FundAmountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FundAmountResponseMultiError, or nil if none found.
func (m *FundAmountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FundAmountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FundDirection

	// no validation rules for TransactionQuantity

	// no validation rules for Amount

	// no validation rules for CnyAmount

	// no validation rules for UsdAmount

	// no validation rules for Dt

	if len(errors) > 0 {
		return FundAmountResponseMultiError(errors)
	}

	return nil
}

// FundAmountResponseMultiError is an error wrapping multiple validation errors
// returned by FundAmountResponse.ValidateAll() if the designated constraints
// aren't met.
type FundAmountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FundAmountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FundAmountResponseMultiError) AllErrors() []error { return m }

// FundAmountResponseValidationError is the validation error returned by
// FundAmountResponse.Validate if the designated constraints aren't met.
type FundAmountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FundAmountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FundAmountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FundAmountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FundAmountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FundAmountResponseValidationError) ErrorName() string {
	return "FundAmountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FundAmountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFundAmountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FundAmountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FundAmountResponseValidationError{}

// Validate checks the field values on FundRateListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FundRateListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FundRateListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FundRateListResponseMultiError, or nil if none found.
func (m *FundRateListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FundRateListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FundRateListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FundRateListResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FundRateListResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FundRateListResponseMultiError(errors)
	}

	return nil
}

// FundRateListResponseMultiError is an error wrapping multiple validation
// errors returned by FundRateListResponse.ValidateAll() if the designated
// constraints aren't met.
type FundRateListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FundRateListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FundRateListResponseMultiError) AllErrors() []error { return m }

// FundRateListResponseValidationError is the validation error returned by
// FundRateListResponse.Validate if the designated constraints aren't met.
type FundRateListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FundRateListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FundRateListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FundRateListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FundRateListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FundRateListResponseValidationError) ErrorName() string {
	return "FundRateListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FundRateListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFundRateListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FundRateListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FundRateListResponseValidationError{}

// Validate checks the field values on FundRateResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FundRateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FundRateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FundRateResponseMultiError, or nil if none found.
func (m *FundRateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FundRateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FundDirection

	// no validation rules for FundType

	// no validation rules for TransactionQuantity

	// no validation rules for Amount

	// no validation rules for CnyAmount

	// no validation rules for UsdAmount

	// no validation rules for Rate

	if len(errors) > 0 {
		return FundRateResponseMultiError(errors)
	}

	return nil
}

// FundRateResponseMultiError is an error wrapping multiple validation errors
// returned by FundRateResponse.ValidateAll() if the designated constraints
// aren't met.
type FundRateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FundRateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FundRateResponseMultiError) AllErrors() []error { return m }

// FundRateResponseValidationError is the validation error returned by
// FundRateResponse.Validate if the designated constraints aren't met.
type FundRateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FundRateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FundRateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FundRateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FundRateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FundRateResponseValidationError) ErrorName() string { return "FundRateResponseValidationError" }

// Error satisfies the builtin error interface
func (e FundRateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFundRateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FundRateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FundRateResponseValidationError{}
